/* soapStub.h
   Generated by gSOAP 2.8.17r from temp.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://tempuri.org/Imports"
#define SOAP_NAMESPACE_OF_tempuri	"http://tempuri.org/"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20817
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREList
#define SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREList (11)
/* tempuri:Get_Hotel_List */
class SOAP_CMAC _tempuri__Get_USCOREHotel_USCOREList
{
public:
	std::wstring *CustomerID;	/* optional element of type xsd:string */
	std::wstring *SignStr;	/* optional element of type xsd:string */
	std::wstring *LastAccessDate;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique type id SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Get_USCOREHotel_USCOREList() { _tempuri__Get_USCOREHotel_USCOREList::soap_default(NULL); }
	virtual ~_tempuri__Get_USCOREHotel_USCOREList() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREListResponse
#define SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREListResponse (12)
/* tempuri:Get_Hotel_ListResponse */
class SOAP_CMAC _tempuri__Get_USCOREHotel_USCOREListResponse
{
public:
	std::wstring *Get_USCOREHotel_USCOREListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique type id SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREListResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Get_USCOREHotel_USCOREListResponse() { _tempuri__Get_USCOREHotel_USCOREListResponse::soap_default(NULL); }
	virtual ~_tempuri__Get_USCOREHotel_USCOREListResponse() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREInfo
#define SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREInfo (13)
/* tempuri:Get_Hotel_Info */
class SOAP_CMAC _tempuri__Get_USCOREHotel_USCOREInfo
{
public:
	std::wstring *CustomerID;	/* optional element of type xsd:string */
	std::wstring *SignStr;	/* optional element of type xsd:string */
	int *HotelID;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique type id SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Get_USCOREHotel_USCOREInfo() { _tempuri__Get_USCOREHotel_USCOREInfo::soap_default(NULL); }
	virtual ~_tempuri__Get_USCOREHotel_USCOREInfo() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREInfoResponse
#define SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREInfoResponse (14)
/* tempuri:Get_Hotel_InfoResponse */
class SOAP_CMAC _tempuri__Get_USCOREHotel_USCOREInfoResponse
{
public:
	std::wstring *Get_USCOREHotel_USCOREInfoResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique type id SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Get_USCOREHotel_USCOREInfoResponse() { _tempuri__Get_USCOREHotel_USCOREInfoResponse::soap_default(NULL); }
	virtual ~_tempuri__Get_USCOREHotel_USCOREInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREPrice
#define SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREPrice (15)
/* tempuri:Get_Hotel_Price */
class SOAP_CMAC _tempuri__Get_USCOREHotel_USCOREPrice
{
public:
	std::wstring *CustomerID;	/* optional element of type xsd:string */
	std::wstring *SignStr;	/* optional element of type xsd:string */
	int *HotelID;	/* optional element of type xsd:int */
	std::wstring *RoomID;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique type id SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREPrice */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Get_USCOREHotel_USCOREPrice() { _tempuri__Get_USCOREHotel_USCOREPrice::soap_default(NULL); }
	virtual ~_tempuri__Get_USCOREHotel_USCOREPrice() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREPriceResponse
#define SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREPriceResponse (16)
/* tempuri:Get_Hotel_PriceResponse */
class SOAP_CMAC _tempuri__Get_USCOREHotel_USCOREPriceResponse
{
public:
	std::wstring *Get_USCOREHotel_USCOREPriceResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique type id SOAP_TYPE__tempuri__Get_USCOREHotel_USCOREPriceResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Get_USCOREHotel_USCOREPriceResponse() { _tempuri__Get_USCOREHotel_USCOREPriceResponse::soap_default(NULL); }
	virtual ~_tempuri__Get_USCOREHotel_USCOREPriceResponse() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Get_USCOREHotel_USCORERoomState
#define SOAP_TYPE__tempuri__Get_USCOREHotel_USCORERoomState (17)
/* tempuri:Get_Hotel_RoomState */
class SOAP_CMAC _tempuri__Get_USCOREHotel_USCORERoomState
{
public:
	std::wstring *CustomerID;	/* optional element of type xsd:string */
	std::wstring *SignStr;	/* optional element of type xsd:string */
	int *HotelID;	/* optional element of type xsd:int */
	std::wstring *RoomID;	/* optional element of type xsd:string */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique type id SOAP_TYPE__tempuri__Get_USCOREHotel_USCORERoomState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Get_USCOREHotel_USCORERoomState() { _tempuri__Get_USCOREHotel_USCORERoomState::soap_default(NULL); }
	virtual ~_tempuri__Get_USCOREHotel_USCORERoomState() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Get_USCOREHotel_USCORERoomStateResponse
#define SOAP_TYPE__tempuri__Get_USCOREHotel_USCORERoomStateResponse (18)
/* tempuri:Get_Hotel_RoomStateResponse */
class SOAP_CMAC _tempuri__Get_USCOREHotel_USCORERoomStateResponse
{
public:
	std::wstring *Get_USCOREHotel_USCORERoomStateResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique type id SOAP_TYPE__tempuri__Get_USCOREHotel_USCORERoomStateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Get_USCOREHotel_USCORERoomStateResponse() { _tempuri__Get_USCOREHotel_USCORERoomStateResponse::soap_default(NULL); }
	virtual ~_tempuri__Get_USCOREHotel_USCORERoomStateResponse() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Book_USCOREAdd
#define SOAP_TYPE__tempuri__Book_USCOREAdd (19)
/* tempuri:Book_Add */
class SOAP_CMAC _tempuri__Book_USCOREAdd
{
public:
	std::wstring *CustomerID;	/* optional element of type xsd:string */
	std::wstring *ContactUser;	/* optional element of type xsd:string */
	std::wstring *ContactName;	/* optional element of type xsd:string */
	int *BookType;	/* optional element of type xsd:int */
	std::wstring *BookInfo;	/* optional element of type xsd:string */
	std::wstring *VeryfyStr;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique type id SOAP_TYPE__tempuri__Book_USCOREAdd */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Book_USCOREAdd() { _tempuri__Book_USCOREAdd::soap_default(NULL); }
	virtual ~_tempuri__Book_USCOREAdd() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Book_USCOREAddResponse
#define SOAP_TYPE__tempuri__Book_USCOREAddResponse (20)
/* tempuri:Book_AddResponse */
class SOAP_CMAC _tempuri__Book_USCOREAddResponse
{
public:
	std::wstring *Book_USCOREAddResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique type id SOAP_TYPE__tempuri__Book_USCOREAddResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Book_USCOREAddResponse() { _tempuri__Book_USCOREAddResponse::soap_default(NULL); }
	virtual ~_tempuri__Book_USCOREAddResponse() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Book_USCOREModify_USCOREHotel
#define SOAP_TYPE__tempuri__Book_USCOREModify_USCOREHotel (21)
/* tempuri:Book_Modify_Hotel */
class SOAP_CMAC _tempuri__Book_USCOREModify_USCOREHotel
{
public:
	std::wstring *CustomerID;	/* optional element of type xsd:string */
	std::wstring *Action;	/* optional element of type xsd:string */
	unsigned char *OrderType;	/* optional element of type xsd:unsignedByte */
	std::wstring *OrderID;	/* optional element of type xsd:string */
	std::wstring *Hotel;	/* optional element of type xsd:string */
	std::wstring *VeryfyStr;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique type id SOAP_TYPE__tempuri__Book_USCOREModify_USCOREHotel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Book_USCOREModify_USCOREHotel() { _tempuri__Book_USCOREModify_USCOREHotel::soap_default(NULL); }
	virtual ~_tempuri__Book_USCOREModify_USCOREHotel() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Book_USCOREModify_USCOREHotelResponse
#define SOAP_TYPE__tempuri__Book_USCOREModify_USCOREHotelResponse (22)
/* tempuri:Book_Modify_HotelResponse */
class SOAP_CMAC _tempuri__Book_USCOREModify_USCOREHotelResponse
{
public:
	std::wstring *Book_USCOREModify_USCOREHotelResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique type id SOAP_TYPE__tempuri__Book_USCOREModify_USCOREHotelResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Book_USCOREModify_USCOREHotelResponse() { _tempuri__Book_USCOREModify_USCOREHotelResponse::soap_default(NULL); }
	virtual ~_tempuri__Book_USCOREModify_USCOREHotelResponse() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Book_USCOREModify_USCOREPlus
#define SOAP_TYPE__tempuri__Book_USCOREModify_USCOREPlus (23)
/* tempuri:Book_Modify_Plus */
class SOAP_CMAC _tempuri__Book_USCOREModify_USCOREPlus
{
public:
	std::wstring *CustomerID;	/* optional element of type xsd:string */
	std::wstring *xhOrderID;	/* optional element of type xsd:string */
	std::wstring *AdditionalProduct;	/* optional element of type xsd:string */
	std::wstring *VeryfyStr;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique type id SOAP_TYPE__tempuri__Book_USCOREModify_USCOREPlus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Book_USCOREModify_USCOREPlus() { _tempuri__Book_USCOREModify_USCOREPlus::soap_default(NULL); }
	virtual ~_tempuri__Book_USCOREModify_USCOREPlus() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Book_USCOREModify_USCOREPlusResponse
#define SOAP_TYPE__tempuri__Book_USCOREModify_USCOREPlusResponse (24)
/* tempuri:Book_Modify_PlusResponse */
class SOAP_CMAC _tempuri__Book_USCOREModify_USCOREPlusResponse
{
public:
	std::wstring *Book_USCOREModify_USCOREPlusResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique type id SOAP_TYPE__tempuri__Book_USCOREModify_USCOREPlusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Book_USCOREModify_USCOREPlusResponse() { _tempuri__Book_USCOREModify_USCOREPlusResponse::soap_default(NULL); }
	virtual ~_tempuri__Book_USCOREModify_USCOREPlusResponse() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Book_USCOREApply
#define SOAP_TYPE__tempuri__Book_USCOREApply (25)
/* tempuri:Book_Apply */
class SOAP_CMAC _tempuri__Book_USCOREApply
{
public:
	std::wstring *CustomerID;	/* optional element of type xsd:string */
	std::wstring *Action;	/* optional element of type xsd:string */
	unsigned char *OrderType;	/* optional element of type xsd:unsignedByte */
	std::wstring *OrderID;	/* optional element of type xsd:string */
	std::wstring *ApplyContent;	/* optional element of type xsd:string */
	std::wstring *VeryfyStr;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique type id SOAP_TYPE__tempuri__Book_USCOREApply */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Book_USCOREApply() { _tempuri__Book_USCOREApply::soap_default(NULL); }
	virtual ~_tempuri__Book_USCOREApply() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Book_USCOREApplyResponse
#define SOAP_TYPE__tempuri__Book_USCOREApplyResponse (26)
/* tempuri:Book_ApplyResponse */
class SOAP_CMAC _tempuri__Book_USCOREApplyResponse
{
public:
	std::wstring *Book_USCOREApplyResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique type id SOAP_TYPE__tempuri__Book_USCOREApplyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Book_USCOREApplyResponse() { _tempuri__Book_USCOREApplyResponse::soap_default(NULL); }
	virtual ~_tempuri__Book_USCOREApplyResponse() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Get_USCOREOrder
#define SOAP_TYPE__tempuri__Get_USCOREOrder (27)
/* tempuri:Get_Order */
class SOAP_CMAC _tempuri__Get_USCOREOrder
{
public:
	std::wstring *CustomerID;	/* optional element of type xsd:string */
	std::wstring *SignStr;	/* optional element of type xsd:string */
	unsigned char *OrderType;	/* optional element of type xsd:unsignedByte */
	std::wstring *OrderID;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique type id SOAP_TYPE__tempuri__Get_USCOREOrder */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Get_USCOREOrder() { _tempuri__Get_USCOREOrder::soap_default(NULL); }
	virtual ~_tempuri__Get_USCOREOrder() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Get_USCOREOrderResponse
#define SOAP_TYPE__tempuri__Get_USCOREOrderResponse (28)
/* tempuri:Get_OrderResponse */
class SOAP_CMAC _tempuri__Get_USCOREOrderResponse
{
public:
	std::wstring *Get_USCOREOrderResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique type id SOAP_TYPE__tempuri__Get_USCOREOrderResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Get_USCOREOrderResponse() { _tempuri__Get_USCOREOrderResponse::soap_default(NULL); }
	virtual ~_tempuri__Get_USCOREOrderResponse() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Get_USCOREOrder_USCOREList
#define SOAP_TYPE__tempuri__Get_USCOREOrder_USCOREList (29)
/* tempuri:Get_Order_List */
class SOAP_CMAC _tempuri__Get_USCOREOrder_USCOREList
{
public:
	std::wstring *CustomerID;	/* optional element of type xsd:string */
	std::wstring *SignStr;	/* optional element of type xsd:string */
	unsigned char *DateType;	/* optional element of type xsd:unsignedByte */
	std::wstring *StartDate;	/* optional element of type xsd:string */
	std::wstring *EndDate;	/* optional element of type xsd:string */
	int *page;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique type id SOAP_TYPE__tempuri__Get_USCOREOrder_USCOREList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Get_USCOREOrder_USCOREList() { _tempuri__Get_USCOREOrder_USCOREList::soap_default(NULL); }
	virtual ~_tempuri__Get_USCOREOrder_USCOREList() { }
};
#endif

#ifndef SOAP_TYPE__tempuri__Get_USCOREOrder_USCOREListResponse
#define SOAP_TYPE__tempuri__Get_USCOREOrder_USCOREListResponse (30)
/* tempuri:Get_Order_ListResponse */
class SOAP_CMAC _tempuri__Get_USCOREOrder_USCOREListResponse
{
public:
	std::wstring *Get_USCOREOrder_USCOREListResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique type id SOAP_TYPE__tempuri__Get_USCOREOrder_USCOREListResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _tempuri__Get_USCOREOrder_USCOREListResponse() { _tempuri__Get_USCOREOrder_USCOREListResponse::soap_default(NULL); }
	virtual ~_tempuri__Get_USCOREOrder_USCOREListResponse() { }
};
#endif

#ifndef SOAP_TYPE___tempuri__Get_USCOREHotel_USCOREList
#define SOAP_TYPE___tempuri__Get_USCOREHotel_USCOREList (39)
/* Operation wrapper: */
struct __tempuri__Get_USCOREHotel_USCOREList
{
public:
	_tempuri__Get_USCOREHotel_USCOREList *tempuri__Get_USCOREHotel_USCOREList;	/* optional element of type tempuri:Get_Hotel_List */
public:
	int soap_type() const { return 39; } /* = unique type id SOAP_TYPE___tempuri__Get_USCOREHotel_USCOREList */
};
#endif

#ifndef SOAP_TYPE___tempuri__Get_USCOREHotel_USCOREInfo
#define SOAP_TYPE___tempuri__Get_USCOREHotel_USCOREInfo (43)
/* Operation wrapper: */
struct __tempuri__Get_USCOREHotel_USCOREInfo
{
public:
	_tempuri__Get_USCOREHotel_USCOREInfo *tempuri__Get_USCOREHotel_USCOREInfo;	/* optional element of type tempuri:Get_Hotel_Info */
public:
	int soap_type() const { return 43; } /* = unique type id SOAP_TYPE___tempuri__Get_USCOREHotel_USCOREInfo */
};
#endif

#ifndef SOAP_TYPE___tempuri__Get_USCOREHotel_USCOREPrice
#define SOAP_TYPE___tempuri__Get_USCOREHotel_USCOREPrice (47)
/* Operation wrapper: */
struct __tempuri__Get_USCOREHotel_USCOREPrice
{
public:
	_tempuri__Get_USCOREHotel_USCOREPrice *tempuri__Get_USCOREHotel_USCOREPrice;	/* optional element of type tempuri:Get_Hotel_Price */
public:
	int soap_type() const { return 47; } /* = unique type id SOAP_TYPE___tempuri__Get_USCOREHotel_USCOREPrice */
};
#endif

#ifndef SOAP_TYPE___tempuri__Get_USCOREHotel_USCORERoomState
#define SOAP_TYPE___tempuri__Get_USCOREHotel_USCORERoomState (51)
/* Operation wrapper: */
struct __tempuri__Get_USCOREHotel_USCORERoomState
{
public:
	_tempuri__Get_USCOREHotel_USCORERoomState *tempuri__Get_USCOREHotel_USCORERoomState;	/* optional element of type tempuri:Get_Hotel_RoomState */
public:
	int soap_type() const { return 51; } /* = unique type id SOAP_TYPE___tempuri__Get_USCOREHotel_USCORERoomState */
};
#endif

#ifndef SOAP_TYPE___tempuri__Book_USCOREAdd
#define SOAP_TYPE___tempuri__Book_USCOREAdd (55)
/* Operation wrapper: */
struct __tempuri__Book_USCOREAdd
{
public:
	_tempuri__Book_USCOREAdd *tempuri__Book_USCOREAdd;	/* optional element of type tempuri:Book_Add */
public:
	int soap_type() const { return 55; } /* = unique type id SOAP_TYPE___tempuri__Book_USCOREAdd */
};
#endif

#ifndef SOAP_TYPE___tempuri__Book_USCOREModify_USCOREHotel
#define SOAP_TYPE___tempuri__Book_USCOREModify_USCOREHotel (59)
/* Operation wrapper: */
struct __tempuri__Book_USCOREModify_USCOREHotel
{
public:
	_tempuri__Book_USCOREModify_USCOREHotel *tempuri__Book_USCOREModify_USCOREHotel;	/* optional element of type tempuri:Book_Modify_Hotel */
public:
	int soap_type() const { return 59; } /* = unique type id SOAP_TYPE___tempuri__Book_USCOREModify_USCOREHotel */
};
#endif

#ifndef SOAP_TYPE___tempuri__Book_USCOREModify_USCOREPlus
#define SOAP_TYPE___tempuri__Book_USCOREModify_USCOREPlus (63)
/* Operation wrapper: */
struct __tempuri__Book_USCOREModify_USCOREPlus
{
public:
	_tempuri__Book_USCOREModify_USCOREPlus *tempuri__Book_USCOREModify_USCOREPlus;	/* optional element of type tempuri:Book_Modify_Plus */
public:
	int soap_type() const { return 63; } /* = unique type id SOAP_TYPE___tempuri__Book_USCOREModify_USCOREPlus */
};
#endif

#ifndef SOAP_TYPE___tempuri__Book_USCOREApply
#define SOAP_TYPE___tempuri__Book_USCOREApply (67)
/* Operation wrapper: */
struct __tempuri__Book_USCOREApply
{
public:
	_tempuri__Book_USCOREApply *tempuri__Book_USCOREApply;	/* optional element of type tempuri:Book_Apply */
public:
	int soap_type() const { return 67; } /* = unique type id SOAP_TYPE___tempuri__Book_USCOREApply */
};
#endif

#ifndef SOAP_TYPE___tempuri__Get_USCOREOrder
#define SOAP_TYPE___tempuri__Get_USCOREOrder (71)
/* Operation wrapper: */
struct __tempuri__Get_USCOREOrder
{
public:
	_tempuri__Get_USCOREOrder *tempuri__Get_USCOREOrder;	/* optional element of type tempuri:Get_Order */
public:
	int soap_type() const { return 71; } /* = unique type id SOAP_TYPE___tempuri__Get_USCOREOrder */
};
#endif

#ifndef SOAP_TYPE___tempuri__Get_USCOREOrder_USCOREList
#define SOAP_TYPE___tempuri__Get_USCOREOrder_USCOREList (75)
/* Operation wrapper: */
struct __tempuri__Get_USCOREOrder_USCOREList
{
public:
	_tempuri__Get_USCOREOrder_USCOREList *tempuri__Get_USCOREOrder_USCOREList;	/* optional element of type tempuri:Get_Order_List */
public:
	int soap_type() const { return 75; } /* = unique type id SOAP_TYPE___tempuri__Get_USCOREOrder_USCOREList */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (76)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 76; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (77)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 77; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (79)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 79; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (82)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 82; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (83)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 83; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (10)
typedef unsigned char xsd__unsignedByte;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
