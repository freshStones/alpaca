/* soapC.cpp
   Generated by gSOAP 2.8.16 from temp.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.16 2013-11-24 13:10:46 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__GetChangeFlightDateResponse:
		return soap_in_PointerTo_ns1__GetChangeFlightDateResponse(soap, NULL, NULL, "ns1:GetChangeFlightDateResponse");
	case SOAP_TYPE_PointerTo_ns1__GetChangeFlightDate:
		return soap_in_PointerTo_ns1__GetChangeFlightDate(soap, NULL, NULL, "ns1:GetChangeFlightDate");
	case SOAP_TYPE_PointerTo_ns1__RefundOrderResponse:
		return soap_in_PointerTo_ns1__RefundOrderResponse(soap, NULL, NULL, "ns1:RefundOrderResponse");
	case SOAP_TYPE_PointerTo_ns1__RefundOrder:
		return soap_in_PointerTo_ns1__RefundOrder(soap, NULL, NULL, "ns1:RefundOrder");
	case SOAP_TYPE_PointerTo_ns1__GetInvalidationProvidersResponse:
		return soap_in_PointerTo_ns1__GetInvalidationProvidersResponse(soap, NULL, NULL, "ns1:GetInvalidationProvidersResponse");
	case SOAP_TYPE_PointerTo_ns1__GetInvalidationProviders:
		return soap_in_PointerTo_ns1__GetInvalidationProviders(soap, NULL, NULL, "ns1:GetInvalidationProviders");
	case SOAP_TYPE_PointerTo_ns1__GetOrderInfoResponse:
		return soap_in_PointerTo_ns1__GetOrderInfoResponse(soap, NULL, NULL, "ns1:GetOrderInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetOrderInfo:
		return soap_in_PointerTo_ns1__GetOrderInfo(soap, NULL, NULL, "ns1:GetOrderInfo");
	case SOAP_TYPE_PointerTo_ns1__RTCreateOrderResponse:
		return soap_in_PointerTo_ns1__RTCreateOrderResponse(soap, NULL, NULL, "ns1:RTCreateOrderResponse");
	case SOAP_TYPE_PointerTo_ns1__RTCreateOrder:
		return soap_in_PointerTo_ns1__RTCreateOrder(soap, NULL, NULL, "ns1:RTCreateOrder");
	case SOAP_TYPE_PointerTo_ns1__DetailCreateOrderResponse:
		return soap_in_PointerTo_ns1__DetailCreateOrderResponse(soap, NULL, NULL, "ns1:DetailCreateOrderResponse");
	case SOAP_TYPE_PointerTo_ns1__DetailCreateOrder:
		return soap_in_PointerTo_ns1__DetailCreateOrder(soap, NULL, NULL, "ns1:DetailCreateOrder");
	case SOAP_TYPE_PointerTo_ns1__GetDomesticMatchNormalZRateByIDResponse:
		return soap_in_PointerTo_ns1__GetDomesticMatchNormalZRateByIDResponse(soap, NULL, NULL, "ns1:GetDomesticMatchNormalZRateByIDResponse");
	case SOAP_TYPE_PointerTo_ns1__GetDomesticMatchNormalZRateByID:
		return soap_in_PointerTo_ns1__GetDomesticMatchNormalZRateByID(soap, NULL, NULL, "ns1:GetDomesticMatchNormalZRateByID");
	case SOAP_TYPE_PointerTo_ns1__GetAVPolicyResponse:
		return soap_in_PointerTo_ns1__GetAVPolicyResponse(soap, NULL, NULL, "ns1:GetAVPolicyResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAVPolicy:
		return soap_in_PointerTo_ns1__GetAVPolicy(soap, NULL, NULL, "ns1:GetAVPolicy");
	case SOAP_TYPE_PointerTo_ns1__MatchCommonPolicyResponse:
		return soap_in_PointerTo_ns1__MatchCommonPolicyResponse(soap, NULL, NULL, "ns1:MatchCommonPolicyResponse");
	case SOAP_TYPE_PointerTo_ns1__MatchCommonPolicy:
		return soap_in_PointerTo_ns1__MatchCommonPolicy(soap, NULL, NULL, "ns1:MatchCommonPolicy");
	case SOAP_TYPE_PointerTo_ns1__GetAlterCommonPolicyResponse:
		return soap_in_PointerTo_ns1__GetAlterCommonPolicyResponse(soap, NULL, NULL, "ns1:GetAlterCommonPolicyResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAlterCommonPolicy:
		return soap_in_PointerTo_ns1__GetAlterCommonPolicy(soap, NULL, NULL, "ns1:GetAlterCommonPolicy");
	case SOAP_TYPE_PointerTo_ns1__GetAllCommonPolicyZIPResponse:
		return soap_in_PointerTo_ns1__GetAllCommonPolicyZIPResponse(soap, NULL, NULL, "ns1:GetAllCommonPolicyZIPResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAllCommonPolicyZIP:
		return soap_in_PointerTo_ns1__GetAllCommonPolicyZIP(soap, NULL, NULL, "ns1:GetAllCommonPolicyZIP");
	case SOAP_TYPE_PointerTo_ns1__GetAllCommonPolicyResponse:
		return soap_in_PointerTo_ns1__GetAllCommonPolicyResponse(soap, NULL, NULL, "ns1:GetAllCommonPolicyResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAllCommonPolicy:
		return soap_in_PointerTo_ns1__GetAllCommonPolicy(soap, NULL, NULL, "ns1:GetAllCommonPolicy");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:GetChangeFlightDateResponse"))
		{	*type = SOAP_TYPE__ns1__GetChangeFlightDateResponse;
			return soap_in__ns1__GetChangeFlightDateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetChangeFlightDate"))
		{	*type = SOAP_TYPE__ns1__GetChangeFlightDate;
			return soap_in__ns1__GetChangeFlightDate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RefundOrderResponse"))
		{	*type = SOAP_TYPE__ns1__RefundOrderResponse;
			return soap_in__ns1__RefundOrderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RefundOrder"))
		{	*type = SOAP_TYPE__ns1__RefundOrder;
			return soap_in__ns1__RefundOrder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetInvalidationProvidersResponse"))
		{	*type = SOAP_TYPE__ns1__GetInvalidationProvidersResponse;
			return soap_in__ns1__GetInvalidationProvidersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetInvalidationProviders"))
		{	*type = SOAP_TYPE__ns1__GetInvalidationProviders;
			return soap_in__ns1__GetInvalidationProviders(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetOrderInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetOrderInfoResponse;
			return soap_in__ns1__GetOrderInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetOrderInfo"))
		{	*type = SOAP_TYPE__ns1__GetOrderInfo;
			return soap_in__ns1__GetOrderInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RTCreateOrderResponse"))
		{	*type = SOAP_TYPE__ns1__RTCreateOrderResponse;
			return soap_in__ns1__RTCreateOrderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RTCreateOrder"))
		{	*type = SOAP_TYPE__ns1__RTCreateOrder;
			return soap_in__ns1__RTCreateOrder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DetailCreateOrderResponse"))
		{	*type = SOAP_TYPE__ns1__DetailCreateOrderResponse;
			return soap_in__ns1__DetailCreateOrderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DetailCreateOrder"))
		{	*type = SOAP_TYPE__ns1__DetailCreateOrder;
			return soap_in__ns1__DetailCreateOrder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDomesticMatchNormalZRateByIDResponse"))
		{	*type = SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByIDResponse;
			return soap_in__ns1__GetDomesticMatchNormalZRateByIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDomesticMatchNormalZRateByID"))
		{	*type = SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByID;
			return soap_in__ns1__GetDomesticMatchNormalZRateByID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAVPolicyResponse"))
		{	*type = SOAP_TYPE__ns1__GetAVPolicyResponse;
			return soap_in__ns1__GetAVPolicyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAVPolicy"))
		{	*type = SOAP_TYPE__ns1__GetAVPolicy;
			return soap_in__ns1__GetAVPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MatchCommonPolicyResponse"))
		{	*type = SOAP_TYPE__ns1__MatchCommonPolicyResponse;
			return soap_in__ns1__MatchCommonPolicyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MatchCommonPolicy"))
		{	*type = SOAP_TYPE__ns1__MatchCommonPolicy;
			return soap_in__ns1__MatchCommonPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlterCommonPolicyResponse"))
		{	*type = SOAP_TYPE__ns1__GetAlterCommonPolicyResponse;
			return soap_in__ns1__GetAlterCommonPolicyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlterCommonPolicy"))
		{	*type = SOAP_TYPE__ns1__GetAlterCommonPolicy;
			return soap_in__ns1__GetAlterCommonPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAllCommonPolicyZIPResponse"))
		{	*type = SOAP_TYPE__ns1__GetAllCommonPolicyZIPResponse;
			return soap_in__ns1__GetAllCommonPolicyZIPResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAllCommonPolicyZIP"))
		{	*type = SOAP_TYPE__ns1__GetAllCommonPolicyZIP;
			return soap_in__ns1__GetAllCommonPolicyZIP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAllCommonPolicyResponse"))
		{	*type = SOAP_TYPE__ns1__GetAllCommonPolicyResponse;
			return soap_in__ns1__GetAllCommonPolicyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAllCommonPolicy"))
		{	*type = SOAP_TYPE__ns1__GetAllCommonPolicy;
			return soap_in__ns1__GetAllCommonPolicy(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__ns1__GetChangeFlightDateResponse:
		return ((_ns1__GetChangeFlightDateResponse *)ptr)->soap_out(soap, "ns1:GetChangeFlightDateResponse", id, NULL);
	case SOAP_TYPE__ns1__GetChangeFlightDate:
		return ((_ns1__GetChangeFlightDate *)ptr)->soap_out(soap, "ns1:GetChangeFlightDate", id, NULL);
	case SOAP_TYPE__ns1__RefundOrderResponse:
		return ((_ns1__RefundOrderResponse *)ptr)->soap_out(soap, "ns1:RefundOrderResponse", id, NULL);
	case SOAP_TYPE__ns1__RefundOrder:
		return ((_ns1__RefundOrder *)ptr)->soap_out(soap, "ns1:RefundOrder", id, NULL);
	case SOAP_TYPE__ns1__GetInvalidationProvidersResponse:
		return ((_ns1__GetInvalidationProvidersResponse *)ptr)->soap_out(soap, "ns1:GetInvalidationProvidersResponse", id, NULL);
	case SOAP_TYPE__ns1__GetInvalidationProviders:
		return ((_ns1__GetInvalidationProviders *)ptr)->soap_out(soap, "ns1:GetInvalidationProviders", id, NULL);
	case SOAP_TYPE__ns1__GetOrderInfoResponse:
		return ((_ns1__GetOrderInfoResponse *)ptr)->soap_out(soap, "ns1:GetOrderInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetOrderInfo:
		return ((_ns1__GetOrderInfo *)ptr)->soap_out(soap, "ns1:GetOrderInfo", id, NULL);
	case SOAP_TYPE__ns1__RTCreateOrderResponse:
		return ((_ns1__RTCreateOrderResponse *)ptr)->soap_out(soap, "ns1:RTCreateOrderResponse", id, NULL);
	case SOAP_TYPE__ns1__RTCreateOrder:
		return ((_ns1__RTCreateOrder *)ptr)->soap_out(soap, "ns1:RTCreateOrder", id, NULL);
	case SOAP_TYPE__ns1__DetailCreateOrderResponse:
		return ((_ns1__DetailCreateOrderResponse *)ptr)->soap_out(soap, "ns1:DetailCreateOrderResponse", id, NULL);
	case SOAP_TYPE__ns1__DetailCreateOrder:
		return ((_ns1__DetailCreateOrder *)ptr)->soap_out(soap, "ns1:DetailCreateOrder", id, NULL);
	case SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByIDResponse:
		return ((_ns1__GetDomesticMatchNormalZRateByIDResponse *)ptr)->soap_out(soap, "ns1:GetDomesticMatchNormalZRateByIDResponse", id, NULL);
	case SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByID:
		return ((_ns1__GetDomesticMatchNormalZRateByID *)ptr)->soap_out(soap, "ns1:GetDomesticMatchNormalZRateByID", id, NULL);
	case SOAP_TYPE__ns1__GetAVPolicyResponse:
		return ((_ns1__GetAVPolicyResponse *)ptr)->soap_out(soap, "ns1:GetAVPolicyResponse", id, NULL);
	case SOAP_TYPE__ns1__GetAVPolicy:
		return ((_ns1__GetAVPolicy *)ptr)->soap_out(soap, "ns1:GetAVPolicy", id, NULL);
	case SOAP_TYPE__ns1__MatchCommonPolicyResponse:
		return ((_ns1__MatchCommonPolicyResponse *)ptr)->soap_out(soap, "ns1:MatchCommonPolicyResponse", id, NULL);
	case SOAP_TYPE__ns1__MatchCommonPolicy:
		return ((_ns1__MatchCommonPolicy *)ptr)->soap_out(soap, "ns1:MatchCommonPolicy", id, NULL);
	case SOAP_TYPE__ns1__GetAlterCommonPolicyResponse:
		return ((_ns1__GetAlterCommonPolicyResponse *)ptr)->soap_out(soap, "ns1:GetAlterCommonPolicyResponse", id, NULL);
	case SOAP_TYPE__ns1__GetAlterCommonPolicy:
		return ((_ns1__GetAlterCommonPolicy *)ptr)->soap_out(soap, "ns1:GetAlterCommonPolicy", id, NULL);
	case SOAP_TYPE__ns1__GetAllCommonPolicyZIPResponse:
		return ((_ns1__GetAllCommonPolicyZIPResponse *)ptr)->soap_out(soap, "ns1:GetAllCommonPolicyZIPResponse", id, NULL);
	case SOAP_TYPE__ns1__GetAllCommonPolicyZIP:
		return ((_ns1__GetAllCommonPolicyZIP *)ptr)->soap_out(soap, "ns1:GetAllCommonPolicyZIP", id, NULL);
	case SOAP_TYPE__ns1__GetAllCommonPolicyResponse:
		return ((_ns1__GetAllCommonPolicyResponse *)ptr)->soap_out(soap, "ns1:GetAllCommonPolicyResponse", id, NULL);
	case SOAP_TYPE__ns1__GetAllCommonPolicy:
		return ((_ns1__GetAllCommonPolicy *)ptr)->soap_out(soap, "ns1:GetAllCommonPolicy", id, NULL);
	case SOAP_TYPE_PointerTo_ns1__GetChangeFlightDateResponse:
		return soap_out_PointerTo_ns1__GetChangeFlightDateResponse(soap, tag, id, (_ns1__GetChangeFlightDateResponse *const*)ptr, "ns1:GetChangeFlightDateResponse");
	case SOAP_TYPE_PointerTo_ns1__GetChangeFlightDate:
		return soap_out_PointerTo_ns1__GetChangeFlightDate(soap, tag, id, (_ns1__GetChangeFlightDate *const*)ptr, "ns1:GetChangeFlightDate");
	case SOAP_TYPE_PointerTo_ns1__RefundOrderResponse:
		return soap_out_PointerTo_ns1__RefundOrderResponse(soap, tag, id, (_ns1__RefundOrderResponse *const*)ptr, "ns1:RefundOrderResponse");
	case SOAP_TYPE_PointerTo_ns1__RefundOrder:
		return soap_out_PointerTo_ns1__RefundOrder(soap, tag, id, (_ns1__RefundOrder *const*)ptr, "ns1:RefundOrder");
	case SOAP_TYPE_PointerTo_ns1__GetInvalidationProvidersResponse:
		return soap_out_PointerTo_ns1__GetInvalidationProvidersResponse(soap, tag, id, (_ns1__GetInvalidationProvidersResponse *const*)ptr, "ns1:GetInvalidationProvidersResponse");
	case SOAP_TYPE_PointerTo_ns1__GetInvalidationProviders:
		return soap_out_PointerTo_ns1__GetInvalidationProviders(soap, tag, id, (_ns1__GetInvalidationProviders *const*)ptr, "ns1:GetInvalidationProviders");
	case SOAP_TYPE_PointerTo_ns1__GetOrderInfoResponse:
		return soap_out_PointerTo_ns1__GetOrderInfoResponse(soap, tag, id, (_ns1__GetOrderInfoResponse *const*)ptr, "ns1:GetOrderInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetOrderInfo:
		return soap_out_PointerTo_ns1__GetOrderInfo(soap, tag, id, (_ns1__GetOrderInfo *const*)ptr, "ns1:GetOrderInfo");
	case SOAP_TYPE_PointerTo_ns1__RTCreateOrderResponse:
		return soap_out_PointerTo_ns1__RTCreateOrderResponse(soap, tag, id, (_ns1__RTCreateOrderResponse *const*)ptr, "ns1:RTCreateOrderResponse");
	case SOAP_TYPE_PointerTo_ns1__RTCreateOrder:
		return soap_out_PointerTo_ns1__RTCreateOrder(soap, tag, id, (_ns1__RTCreateOrder *const*)ptr, "ns1:RTCreateOrder");
	case SOAP_TYPE_PointerTo_ns1__DetailCreateOrderResponse:
		return soap_out_PointerTo_ns1__DetailCreateOrderResponse(soap, tag, id, (_ns1__DetailCreateOrderResponse *const*)ptr, "ns1:DetailCreateOrderResponse");
	case SOAP_TYPE_PointerTo_ns1__DetailCreateOrder:
		return soap_out_PointerTo_ns1__DetailCreateOrder(soap, tag, id, (_ns1__DetailCreateOrder *const*)ptr, "ns1:DetailCreateOrder");
	case SOAP_TYPE_PointerTo_ns1__GetDomesticMatchNormalZRateByIDResponse:
		return soap_out_PointerTo_ns1__GetDomesticMatchNormalZRateByIDResponse(soap, tag, id, (_ns1__GetDomesticMatchNormalZRateByIDResponse *const*)ptr, "ns1:GetDomesticMatchNormalZRateByIDResponse");
	case SOAP_TYPE_PointerTo_ns1__GetDomesticMatchNormalZRateByID:
		return soap_out_PointerTo_ns1__GetDomesticMatchNormalZRateByID(soap, tag, id, (_ns1__GetDomesticMatchNormalZRateByID *const*)ptr, "ns1:GetDomesticMatchNormalZRateByID");
	case SOAP_TYPE_PointerTo_ns1__GetAVPolicyResponse:
		return soap_out_PointerTo_ns1__GetAVPolicyResponse(soap, tag, id, (_ns1__GetAVPolicyResponse *const*)ptr, "ns1:GetAVPolicyResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAVPolicy:
		return soap_out_PointerTo_ns1__GetAVPolicy(soap, tag, id, (_ns1__GetAVPolicy *const*)ptr, "ns1:GetAVPolicy");
	case SOAP_TYPE_PointerTo_ns1__MatchCommonPolicyResponse:
		return soap_out_PointerTo_ns1__MatchCommonPolicyResponse(soap, tag, id, (_ns1__MatchCommonPolicyResponse *const*)ptr, "ns1:MatchCommonPolicyResponse");
	case SOAP_TYPE_PointerTo_ns1__MatchCommonPolicy:
		return soap_out_PointerTo_ns1__MatchCommonPolicy(soap, tag, id, (_ns1__MatchCommonPolicy *const*)ptr, "ns1:MatchCommonPolicy");
	case SOAP_TYPE_PointerTo_ns1__GetAlterCommonPolicyResponse:
		return soap_out_PointerTo_ns1__GetAlterCommonPolicyResponse(soap, tag, id, (_ns1__GetAlterCommonPolicyResponse *const*)ptr, "ns1:GetAlterCommonPolicyResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAlterCommonPolicy:
		return soap_out_PointerTo_ns1__GetAlterCommonPolicy(soap, tag, id, (_ns1__GetAlterCommonPolicy *const*)ptr, "ns1:GetAlterCommonPolicy");
	case SOAP_TYPE_PointerTo_ns1__GetAllCommonPolicyZIPResponse:
		return soap_out_PointerTo_ns1__GetAllCommonPolicyZIPResponse(soap, tag, id, (_ns1__GetAllCommonPolicyZIPResponse *const*)ptr, "ns1:GetAllCommonPolicyZIPResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAllCommonPolicyZIP:
		return soap_out_PointerTo_ns1__GetAllCommonPolicyZIP(soap, tag, id, (_ns1__GetAllCommonPolicyZIP *const*)ptr, "ns1:GetAllCommonPolicyZIP");
	case SOAP_TYPE_PointerTo_ns1__GetAllCommonPolicyResponse:
		return soap_out_PointerTo_ns1__GetAllCommonPolicyResponse(soap, tag, id, (_ns1__GetAllCommonPolicyResponse *const*)ptr, "ns1:GetAllCommonPolicyResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAllCommonPolicy:
		return soap_out_PointerTo_ns1__GetAllCommonPolicy(soap, tag, id, (_ns1__GetAllCommonPolicy *const*)ptr, "ns1:GetAllCommonPolicy");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns1__GetChangeFlightDateResponse:
		((_ns1__GetChangeFlightDateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetChangeFlightDate:
		((_ns1__GetChangeFlightDate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RefundOrderResponse:
		((_ns1__RefundOrderResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RefundOrder:
		((_ns1__RefundOrder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetInvalidationProvidersResponse:
		((_ns1__GetInvalidationProvidersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetInvalidationProviders:
		((_ns1__GetInvalidationProviders *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetOrderInfoResponse:
		((_ns1__GetOrderInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetOrderInfo:
		((_ns1__GetOrderInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RTCreateOrderResponse:
		((_ns1__RTCreateOrderResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RTCreateOrder:
		((_ns1__RTCreateOrder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DetailCreateOrderResponse:
		((_ns1__DetailCreateOrderResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DetailCreateOrder:
		((_ns1__DetailCreateOrder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByIDResponse:
		((_ns1__GetDomesticMatchNormalZRateByIDResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByID:
		((_ns1__GetDomesticMatchNormalZRateByID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAVPolicyResponse:
		((_ns1__GetAVPolicyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAVPolicy:
		((_ns1__GetAVPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__MatchCommonPolicyResponse:
		((_ns1__MatchCommonPolicyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__MatchCommonPolicy:
		((_ns1__MatchCommonPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAlterCommonPolicyResponse:
		((_ns1__GetAlterCommonPolicyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAlterCommonPolicy:
		((_ns1__GetAlterCommonPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAllCommonPolicyZIPResponse:
		((_ns1__GetAllCommonPolicyZIPResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAllCommonPolicyZIP:
		((_ns1__GetAllCommonPolicyZIP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAllCommonPolicyResponse:
		((_ns1__GetAllCommonPolicyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAllCommonPolicy:
		((_ns1__GetAllCommonPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__GetChangeFlightDate_:
		soap_serialize___ns1__GetChangeFlightDate_(soap, (const struct __ns1__GetChangeFlightDate_ *)ptr);
		break;
	case SOAP_TYPE___ns1__RefundOrder_:
		soap_serialize___ns1__RefundOrder_(soap, (const struct __ns1__RefundOrder_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetInvalidationProviders_:
		soap_serialize___ns1__GetInvalidationProviders_(soap, (const struct __ns1__GetInvalidationProviders_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetOrderInfo_:
		soap_serialize___ns1__GetOrderInfo_(soap, (const struct __ns1__GetOrderInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__RTCreateOrder_:
		soap_serialize___ns1__RTCreateOrder_(soap, (const struct __ns1__RTCreateOrder_ *)ptr);
		break;
	case SOAP_TYPE___ns1__DetailCreateOrder_:
		soap_serialize___ns1__DetailCreateOrder_(soap, (const struct __ns1__DetailCreateOrder_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDomesticMatchNormalZRateByID_:
		soap_serialize___ns1__GetDomesticMatchNormalZRateByID_(soap, (const struct __ns1__GetDomesticMatchNormalZRateByID_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAVPolicy_:
		soap_serialize___ns1__GetAVPolicy_(soap, (const struct __ns1__GetAVPolicy_ *)ptr);
		break;
	case SOAP_TYPE___ns1__MatchCommonPolicy_:
		soap_serialize___ns1__MatchCommonPolicy_(soap, (const struct __ns1__MatchCommonPolicy_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAlterCommonPolicy_:
		soap_serialize___ns1__GetAlterCommonPolicy_(soap, (const struct __ns1__GetAlterCommonPolicy_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAllCommonPolicyZIP_:
		soap_serialize___ns1__GetAllCommonPolicyZIP_(soap, (const struct __ns1__GetAllCommonPolicyZIP_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAllCommonPolicy_:
		soap_serialize___ns1__GetAllCommonPolicy_(soap, (const struct __ns1__GetAllCommonPolicy_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetChangeFlightDate:
		soap_serialize___ns1__GetChangeFlightDate(soap, (const struct __ns1__GetChangeFlightDate *)ptr);
		break;
	case SOAP_TYPE___ns1__RefundOrder:
		soap_serialize___ns1__RefundOrder(soap, (const struct __ns1__RefundOrder *)ptr);
		break;
	case SOAP_TYPE___ns1__GetInvalidationProviders:
		soap_serialize___ns1__GetInvalidationProviders(soap, (const struct __ns1__GetInvalidationProviders *)ptr);
		break;
	case SOAP_TYPE___ns1__GetOrderInfo:
		soap_serialize___ns1__GetOrderInfo(soap, (const struct __ns1__GetOrderInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__RTCreateOrder:
		soap_serialize___ns1__RTCreateOrder(soap, (const struct __ns1__RTCreateOrder *)ptr);
		break;
	case SOAP_TYPE___ns1__DetailCreateOrder:
		soap_serialize___ns1__DetailCreateOrder(soap, (const struct __ns1__DetailCreateOrder *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDomesticMatchNormalZRateByID:
		soap_serialize___ns1__GetDomesticMatchNormalZRateByID(soap, (const struct __ns1__GetDomesticMatchNormalZRateByID *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAVPolicy:
		soap_serialize___ns1__GetAVPolicy(soap, (const struct __ns1__GetAVPolicy *)ptr);
		break;
	case SOAP_TYPE___ns1__MatchCommonPolicy:
		soap_serialize___ns1__MatchCommonPolicy(soap, (const struct __ns1__MatchCommonPolicy *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAlterCommonPolicy:
		soap_serialize___ns1__GetAlterCommonPolicy(soap, (const struct __ns1__GetAlterCommonPolicy *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAllCommonPolicyZIP:
		soap_serialize___ns1__GetAllCommonPolicyZIP(soap, (const struct __ns1__GetAllCommonPolicyZIP *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAllCommonPolicy:
		soap_serialize___ns1__GetAllCommonPolicy(soap, (const struct __ns1__GetAllCommonPolicy *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetChangeFlightDateResponse:
		soap_serialize_PointerTo_ns1__GetChangeFlightDateResponse(soap, (_ns1__GetChangeFlightDateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetChangeFlightDate:
		soap_serialize_PointerTo_ns1__GetChangeFlightDate(soap, (_ns1__GetChangeFlightDate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RefundOrderResponse:
		soap_serialize_PointerTo_ns1__RefundOrderResponse(soap, (_ns1__RefundOrderResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RefundOrder:
		soap_serialize_PointerTo_ns1__RefundOrder(soap, (_ns1__RefundOrder *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetInvalidationProvidersResponse:
		soap_serialize_PointerTo_ns1__GetInvalidationProvidersResponse(soap, (_ns1__GetInvalidationProvidersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetInvalidationProviders:
		soap_serialize_PointerTo_ns1__GetInvalidationProviders(soap, (_ns1__GetInvalidationProviders *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetOrderInfoResponse:
		soap_serialize_PointerTo_ns1__GetOrderInfoResponse(soap, (_ns1__GetOrderInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetOrderInfo:
		soap_serialize_PointerTo_ns1__GetOrderInfo(soap, (_ns1__GetOrderInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RTCreateOrderResponse:
		soap_serialize_PointerTo_ns1__RTCreateOrderResponse(soap, (_ns1__RTCreateOrderResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RTCreateOrder:
		soap_serialize_PointerTo_ns1__RTCreateOrder(soap, (_ns1__RTCreateOrder *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DetailCreateOrderResponse:
		soap_serialize_PointerTo_ns1__DetailCreateOrderResponse(soap, (_ns1__DetailCreateOrderResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DetailCreateOrder:
		soap_serialize_PointerTo_ns1__DetailCreateOrder(soap, (_ns1__DetailCreateOrder *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDomesticMatchNormalZRateByIDResponse:
		soap_serialize_PointerTo_ns1__GetDomesticMatchNormalZRateByIDResponse(soap, (_ns1__GetDomesticMatchNormalZRateByIDResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDomesticMatchNormalZRateByID:
		soap_serialize_PointerTo_ns1__GetDomesticMatchNormalZRateByID(soap, (_ns1__GetDomesticMatchNormalZRateByID *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAVPolicyResponse:
		soap_serialize_PointerTo_ns1__GetAVPolicyResponse(soap, (_ns1__GetAVPolicyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAVPolicy:
		soap_serialize_PointerTo_ns1__GetAVPolicy(soap, (_ns1__GetAVPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__MatchCommonPolicyResponse:
		soap_serialize_PointerTo_ns1__MatchCommonPolicyResponse(soap, (_ns1__MatchCommonPolicyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__MatchCommonPolicy:
		soap_serialize_PointerTo_ns1__MatchCommonPolicy(soap, (_ns1__MatchCommonPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAlterCommonPolicyResponse:
		soap_serialize_PointerTo_ns1__GetAlterCommonPolicyResponse(soap, (_ns1__GetAlterCommonPolicyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAlterCommonPolicy:
		soap_serialize_PointerTo_ns1__GetAlterCommonPolicy(soap, (_ns1__GetAlterCommonPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAllCommonPolicyZIPResponse:
		soap_serialize_PointerTo_ns1__GetAllCommonPolicyZIPResponse(soap, (_ns1__GetAllCommonPolicyZIPResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAllCommonPolicyZIP:
		soap_serialize_PointerTo_ns1__GetAllCommonPolicyZIP(soap, (_ns1__GetAllCommonPolicyZIP *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAllCommonPolicyResponse:
		soap_serialize_PointerTo_ns1__GetAllCommonPolicyResponse(soap, (_ns1__GetAllCommonPolicyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAllCommonPolicy:
		soap_serialize_PointerTo_ns1__GetAllCommonPolicy(soap, (_ns1__GetAllCommonPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAllCommonPolicy:
		return (void*)soap_instantiate__ns1__GetAllCommonPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAllCommonPolicyResponse:
		return (void*)soap_instantiate__ns1__GetAllCommonPolicyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAllCommonPolicyZIP:
		return (void*)soap_instantiate__ns1__GetAllCommonPolicyZIP(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAllCommonPolicyZIPResponse:
		return (void*)soap_instantiate__ns1__GetAllCommonPolicyZIPResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAlterCommonPolicy:
		return (void*)soap_instantiate__ns1__GetAlterCommonPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAlterCommonPolicyResponse:
		return (void*)soap_instantiate__ns1__GetAlterCommonPolicyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__MatchCommonPolicy:
		return (void*)soap_instantiate__ns1__MatchCommonPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__MatchCommonPolicyResponse:
		return (void*)soap_instantiate__ns1__MatchCommonPolicyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAVPolicy:
		return (void*)soap_instantiate__ns1__GetAVPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAVPolicyResponse:
		return (void*)soap_instantiate__ns1__GetAVPolicyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByID:
		return (void*)soap_instantiate__ns1__GetDomesticMatchNormalZRateByID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByIDResponse:
		return (void*)soap_instantiate__ns1__GetDomesticMatchNormalZRateByIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DetailCreateOrder:
		return (void*)soap_instantiate__ns1__DetailCreateOrder(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DetailCreateOrderResponse:
		return (void*)soap_instantiate__ns1__DetailCreateOrderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RTCreateOrder:
		return (void*)soap_instantiate__ns1__RTCreateOrder(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RTCreateOrderResponse:
		return (void*)soap_instantiate__ns1__RTCreateOrderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetOrderInfo:
		return (void*)soap_instantiate__ns1__GetOrderInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetOrderInfoResponse:
		return (void*)soap_instantiate__ns1__GetOrderInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetInvalidationProviders:
		return (void*)soap_instantiate__ns1__GetInvalidationProviders(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetInvalidationProvidersResponse:
		return (void*)soap_instantiate__ns1__GetInvalidationProvidersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RefundOrder:
		return (void*)soap_instantiate__ns1__RefundOrder(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RefundOrderResponse:
		return (void*)soap_instantiate__ns1__RefundOrderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetChangeFlightDate:
		return (void*)soap_instantiate__ns1__GetChangeFlightDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetChangeFlightDateResponse:
		return (void*)soap_instantiate__ns1__GetChangeFlightDateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAllCommonPolicy:
		return (void*)soap_instantiate___ns1__GetAllCommonPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAllCommonPolicyZIP:
		return (void*)soap_instantiate___ns1__GetAllCommonPolicyZIP(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAlterCommonPolicy:
		return (void*)soap_instantiate___ns1__GetAlterCommonPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__MatchCommonPolicy:
		return (void*)soap_instantiate___ns1__MatchCommonPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAVPolicy:
		return (void*)soap_instantiate___ns1__GetAVPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDomesticMatchNormalZRateByID:
		return (void*)soap_instantiate___ns1__GetDomesticMatchNormalZRateByID(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DetailCreateOrder:
		return (void*)soap_instantiate___ns1__DetailCreateOrder(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__RTCreateOrder:
		return (void*)soap_instantiate___ns1__RTCreateOrder(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetOrderInfo:
		return (void*)soap_instantiate___ns1__GetOrderInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetInvalidationProviders:
		return (void*)soap_instantiate___ns1__GetInvalidationProviders(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__RefundOrder:
		return (void*)soap_instantiate___ns1__RefundOrder(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetChangeFlightDate:
		return (void*)soap_instantiate___ns1__GetChangeFlightDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAllCommonPolicy_:
		return (void*)soap_instantiate___ns1__GetAllCommonPolicy_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAllCommonPolicyZIP_:
		return (void*)soap_instantiate___ns1__GetAllCommonPolicyZIP_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAlterCommonPolicy_:
		return (void*)soap_instantiate___ns1__GetAlterCommonPolicy_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__MatchCommonPolicy_:
		return (void*)soap_instantiate___ns1__MatchCommonPolicy_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAVPolicy_:
		return (void*)soap_instantiate___ns1__GetAVPolicy_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDomesticMatchNormalZRateByID_:
		return (void*)soap_instantiate___ns1__GetDomesticMatchNormalZRateByID_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DetailCreateOrder_:
		return (void*)soap_instantiate___ns1__DetailCreateOrder_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__RTCreateOrder_:
		return (void*)soap_instantiate___ns1__RTCreateOrder_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetOrderInfo_:
		return (void*)soap_instantiate___ns1__GetOrderInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetInvalidationProviders_:
		return (void*)soap_instantiate___ns1__GetInvalidationProviders_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__RefundOrder_:
		return (void*)soap_instantiate___ns1__RefundOrder_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetChangeFlightDate_:
		return (void*)soap_instantiate___ns1__GetChangeFlightDate_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAllCommonPolicy:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAllCommonPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAllCommonPolicy*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAllCommonPolicyResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAllCommonPolicyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAllCommonPolicyResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAllCommonPolicyZIP:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAllCommonPolicyZIP*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAllCommonPolicyZIP*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAllCommonPolicyZIPResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAllCommonPolicyZIPResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAllCommonPolicyZIPResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAlterCommonPolicy:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAlterCommonPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAlterCommonPolicy*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAlterCommonPolicyResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAlterCommonPolicyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAlterCommonPolicyResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__MatchCommonPolicy:
		if (p->size < 0)
			SOAP_DELETE((_ns1__MatchCommonPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__MatchCommonPolicy*)p->ptr);
		break;
	case SOAP_TYPE__ns1__MatchCommonPolicyResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__MatchCommonPolicyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__MatchCommonPolicyResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAVPolicy:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAVPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAVPolicy*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAVPolicyResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAVPolicyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAVPolicyResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByID:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetDomesticMatchNormalZRateByID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetDomesticMatchNormalZRateByID*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByIDResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetDomesticMatchNormalZRateByIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetDomesticMatchNormalZRateByIDResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DetailCreateOrder:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DetailCreateOrder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DetailCreateOrder*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DetailCreateOrderResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DetailCreateOrderResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DetailCreateOrderResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__RTCreateOrder:
		if (p->size < 0)
			SOAP_DELETE((_ns1__RTCreateOrder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__RTCreateOrder*)p->ptr);
		break;
	case SOAP_TYPE__ns1__RTCreateOrderResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__RTCreateOrderResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__RTCreateOrderResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetOrderInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetOrderInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetOrderInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetOrderInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetOrderInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetOrderInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetInvalidationProviders:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetInvalidationProviders*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetInvalidationProviders*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetInvalidationProvidersResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetInvalidationProvidersResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetInvalidationProvidersResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__RefundOrder:
		if (p->size < 0)
			SOAP_DELETE((_ns1__RefundOrder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__RefundOrder*)p->ptr);
		break;
	case SOAP_TYPE__ns1__RefundOrderResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__RefundOrderResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__RefundOrderResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetChangeFlightDate:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetChangeFlightDate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetChangeFlightDate*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetChangeFlightDateResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetChangeFlightDateResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetChangeFlightDateResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetAllCommonPolicy:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetAllCommonPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetAllCommonPolicy*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetAllCommonPolicyZIP:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetAllCommonPolicyZIP*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetAllCommonPolicyZIP*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetAlterCommonPolicy:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetAlterCommonPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetAlterCommonPolicy*)p->ptr);
		break;
	case SOAP_TYPE___ns1__MatchCommonPolicy:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__MatchCommonPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__MatchCommonPolicy*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetAVPolicy:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetAVPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetAVPolicy*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetDomesticMatchNormalZRateByID:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetDomesticMatchNormalZRateByID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetDomesticMatchNormalZRateByID*)p->ptr);
		break;
	case SOAP_TYPE___ns1__DetailCreateOrder:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__DetailCreateOrder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__DetailCreateOrder*)p->ptr);
		break;
	case SOAP_TYPE___ns1__RTCreateOrder:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__RTCreateOrder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__RTCreateOrder*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetOrderInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetOrderInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetOrderInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetInvalidationProviders:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetInvalidationProviders*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetInvalidationProviders*)p->ptr);
		break;
	case SOAP_TYPE___ns1__RefundOrder:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__RefundOrder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__RefundOrder*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetChangeFlightDate:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetChangeFlightDate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetChangeFlightDate*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetAllCommonPolicy_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetAllCommonPolicy_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetAllCommonPolicy_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetAllCommonPolicyZIP_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetAllCommonPolicyZIP_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetAllCommonPolicyZIP_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetAlterCommonPolicy_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetAlterCommonPolicy_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetAlterCommonPolicy_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__MatchCommonPolicy_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__MatchCommonPolicy_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__MatchCommonPolicy_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetAVPolicy_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetAVPolicy_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetAVPolicy_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetDomesticMatchNormalZRateByID_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetDomesticMatchNormalZRateByID_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetDomesticMatchNormalZRateByID_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__DetailCreateOrder_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__DetailCreateOrder_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__DetailCreateOrder_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__RTCreateOrder_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__RTCreateOrder_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__RTCreateOrder_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetOrderInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetOrderInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetOrderInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetInvalidationProviders_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetInvalidationProviders_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetInvalidationProviders_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__RefundOrder_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__RefundOrder_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__RefundOrder_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetChangeFlightDate_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetChangeFlightDate_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetChangeFlightDate_*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void _ns1__GetChangeFlightDateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetChangeFlightDateResponse::GetChangeFlightDateResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetChangeFlightDateResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetChangeFlightDateResponse::GetChangeFlightDateResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetChangeFlightDateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetChangeFlightDateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetChangeFlightDateResponse(struct soap *soap, const char *tag, int id, const _ns1__GetChangeFlightDateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetChangeFlightDateResponse), type))
		return soap->error;
	if (a->GetChangeFlightDateResult)
		soap_element_result(soap, "ns1:GetChangeFlightDateResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetChangeFlightDateResult", -1, &(a->_ns1__GetChangeFlightDateResponse::GetChangeFlightDateResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetChangeFlightDateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetChangeFlightDateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetChangeFlightDateResponse * SOAP_FMAC4 soap_in__ns1__GetChangeFlightDateResponse(struct soap *soap, const char *tag, _ns1__GetChangeFlightDateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetChangeFlightDateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetChangeFlightDateResponse, sizeof(_ns1__GetChangeFlightDateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetChangeFlightDateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetChangeFlightDateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetChangeFlightDateResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetChangeFlightDateResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:GetChangeFlightDateResult", &(a->_ns1__GetChangeFlightDateResponse::GetChangeFlightDateResult), "xsd:string"))
				{	soap_flag_GetChangeFlightDateResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetChangeFlightDateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetChangeFlightDateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetChangeFlightDateResponse, 0, sizeof(_ns1__GetChangeFlightDateResponse), 0, soap_copy__ns1__GetChangeFlightDateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetChangeFlightDateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetChangeFlightDateResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetChangeFlightDateResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetChangeFlightDateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetChangeFlightDateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetChangeFlightDateResponse * SOAP_FMAC4 soap_get__ns1__GetChangeFlightDateResponse(struct soap *soap, _ns1__GetChangeFlightDateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetChangeFlightDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetChangeFlightDateResponse * SOAP_FMAC2 soap_instantiate__ns1__GetChangeFlightDateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetChangeFlightDateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetChangeFlightDateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetChangeFlightDateResponse);
		if (size)
			*size = sizeof(_ns1__GetChangeFlightDateResponse);
		((_ns1__GetChangeFlightDateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetChangeFlightDateResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetChangeFlightDateResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetChangeFlightDateResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetChangeFlightDateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetChangeFlightDateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetChangeFlightDateResponse %p -> %p\n", q, p));
	*(_ns1__GetChangeFlightDateResponse*)p = *(_ns1__GetChangeFlightDateResponse*)q;
}

void _ns1__GetChangeFlightDate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetChangeFlightDate::xmlDoc = NULL;
	/* transient soap skipped */
}

void _ns1__GetChangeFlightDate::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetChangeFlightDate::xmlDoc);
	/* transient soap skipped */
#endif
}

int _ns1__GetChangeFlightDate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetChangeFlightDate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetChangeFlightDate(struct soap *soap, const char *tag, int id, const _ns1__GetChangeFlightDate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetChangeFlightDate), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:xmlDoc", -1, &(a->_ns1__GetChangeFlightDate::xmlDoc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetChangeFlightDate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetChangeFlightDate(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetChangeFlightDate * SOAP_FMAC4 soap_in__ns1__GetChangeFlightDate(struct soap *soap, const char *tag, _ns1__GetChangeFlightDate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetChangeFlightDate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetChangeFlightDate, sizeof(_ns1__GetChangeFlightDate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetChangeFlightDate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetChangeFlightDate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlDoc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlDoc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:xmlDoc", &(a->_ns1__GetChangeFlightDate::xmlDoc), "xsd:string"))
				{	soap_flag_xmlDoc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetChangeFlightDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetChangeFlightDate, 0, sizeof(_ns1__GetChangeFlightDate), 0, soap_copy__ns1__GetChangeFlightDate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetChangeFlightDate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetChangeFlightDate);
	if (this->soap_out(soap, tag?tag:"ns1:GetChangeFlightDate", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetChangeFlightDate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetChangeFlightDate(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetChangeFlightDate * SOAP_FMAC4 soap_get__ns1__GetChangeFlightDate(struct soap *soap, _ns1__GetChangeFlightDate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetChangeFlightDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetChangeFlightDate * SOAP_FMAC2 soap_instantiate__ns1__GetChangeFlightDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetChangeFlightDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetChangeFlightDate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetChangeFlightDate);
		if (size)
			*size = sizeof(_ns1__GetChangeFlightDate);
		((_ns1__GetChangeFlightDate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetChangeFlightDate, n);
		if (size)
			*size = n * sizeof(_ns1__GetChangeFlightDate);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetChangeFlightDate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetChangeFlightDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetChangeFlightDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetChangeFlightDate %p -> %p\n", q, p));
	*(_ns1__GetChangeFlightDate*)p = *(_ns1__GetChangeFlightDate*)q;
}

void _ns1__RefundOrderResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__RefundOrderResponse::RefundOrderResult = NULL;
	/* transient soap skipped */
}

void _ns1__RefundOrderResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__RefundOrderResponse::RefundOrderResult);
	/* transient soap skipped */
#endif
}

int _ns1__RefundOrderResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RefundOrderResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RefundOrderResponse(struct soap *soap, const char *tag, int id, const _ns1__RefundOrderResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RefundOrderResponse), type))
		return soap->error;
	if (a->RefundOrderResult)
		soap_element_result(soap, "ns1:RefundOrderResult");
	if (soap_out_PointerTostd__string(soap, "ns1:RefundOrderResult", -1, &(a->_ns1__RefundOrderResponse::RefundOrderResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__RefundOrderResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RefundOrderResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RefundOrderResponse * SOAP_FMAC4 soap_in__ns1__RefundOrderResponse(struct soap *soap, const char *tag, _ns1__RefundOrderResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RefundOrderResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RefundOrderResponse, sizeof(_ns1__RefundOrderResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__RefundOrderResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__RefundOrderResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RefundOrderResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RefundOrderResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:RefundOrderResult", &(a->_ns1__RefundOrderResponse::RefundOrderResult), "xsd:string"))
				{	soap_flag_RefundOrderResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:RefundOrderResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RefundOrderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RefundOrderResponse, 0, sizeof(_ns1__RefundOrderResponse), 0, soap_copy__ns1__RefundOrderResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__RefundOrderResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__RefundOrderResponse);
	if (this->soap_out(soap, tag?tag:"ns1:RefundOrderResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RefundOrderResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RefundOrderResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RefundOrderResponse * SOAP_FMAC4 soap_get__ns1__RefundOrderResponse(struct soap *soap, _ns1__RefundOrderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RefundOrderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__RefundOrderResponse * SOAP_FMAC2 soap_instantiate__ns1__RefundOrderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RefundOrderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__RefundOrderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RefundOrderResponse);
		if (size)
			*size = sizeof(_ns1__RefundOrderResponse);
		((_ns1__RefundOrderResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__RefundOrderResponse, n);
		if (size)
			*size = n * sizeof(_ns1__RefundOrderResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__RefundOrderResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__RefundOrderResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__RefundOrderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__RefundOrderResponse %p -> %p\n", q, p));
	*(_ns1__RefundOrderResponse*)p = *(_ns1__RefundOrderResponse*)q;
}

void _ns1__RefundOrder::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__RefundOrder::xmlDoc = NULL;
	/* transient soap skipped */
}

void _ns1__RefundOrder::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__RefundOrder::xmlDoc);
	/* transient soap skipped */
#endif
}

int _ns1__RefundOrder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RefundOrder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RefundOrder(struct soap *soap, const char *tag, int id, const _ns1__RefundOrder *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RefundOrder), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:xmlDoc", -1, &(a->_ns1__RefundOrder::xmlDoc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__RefundOrder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RefundOrder(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RefundOrder * SOAP_FMAC4 soap_in__ns1__RefundOrder(struct soap *soap, const char *tag, _ns1__RefundOrder *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RefundOrder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RefundOrder, sizeof(_ns1__RefundOrder), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__RefundOrder)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__RefundOrder *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlDoc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlDoc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:xmlDoc", &(a->_ns1__RefundOrder::xmlDoc), "xsd:string"))
				{	soap_flag_xmlDoc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RefundOrder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RefundOrder, 0, sizeof(_ns1__RefundOrder), 0, soap_copy__ns1__RefundOrder);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__RefundOrder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__RefundOrder);
	if (this->soap_out(soap, tag?tag:"ns1:RefundOrder", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RefundOrder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RefundOrder(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RefundOrder * SOAP_FMAC4 soap_get__ns1__RefundOrder(struct soap *soap, _ns1__RefundOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RefundOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__RefundOrder * SOAP_FMAC2 soap_instantiate__ns1__RefundOrder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RefundOrder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__RefundOrder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RefundOrder);
		if (size)
			*size = sizeof(_ns1__RefundOrder);
		((_ns1__RefundOrder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__RefundOrder, n);
		if (size)
			*size = n * sizeof(_ns1__RefundOrder);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__RefundOrder*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__RefundOrder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__RefundOrder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__RefundOrder %p -> %p\n", q, p));
	*(_ns1__RefundOrder*)p = *(_ns1__RefundOrder*)q;
}

void _ns1__GetInvalidationProvidersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetInvalidationProvidersResponse::GetInvalidationProvidersResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetInvalidationProvidersResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetInvalidationProvidersResponse::GetInvalidationProvidersResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetInvalidationProvidersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetInvalidationProvidersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetInvalidationProvidersResponse(struct soap *soap, const char *tag, int id, const _ns1__GetInvalidationProvidersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetInvalidationProvidersResponse), type))
		return soap->error;
	if (a->GetInvalidationProvidersResult)
		soap_element_result(soap, "ns1:GetInvalidationProvidersResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetInvalidationProvidersResult", -1, &(a->_ns1__GetInvalidationProvidersResponse::GetInvalidationProvidersResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetInvalidationProvidersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetInvalidationProvidersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetInvalidationProvidersResponse * SOAP_FMAC4 soap_in__ns1__GetInvalidationProvidersResponse(struct soap *soap, const char *tag, _ns1__GetInvalidationProvidersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetInvalidationProvidersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetInvalidationProvidersResponse, sizeof(_ns1__GetInvalidationProvidersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetInvalidationProvidersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetInvalidationProvidersResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetInvalidationProvidersResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetInvalidationProvidersResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:GetInvalidationProvidersResult", &(a->_ns1__GetInvalidationProvidersResponse::GetInvalidationProvidersResult), "xsd:string"))
				{	soap_flag_GetInvalidationProvidersResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetInvalidationProvidersResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetInvalidationProvidersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetInvalidationProvidersResponse, 0, sizeof(_ns1__GetInvalidationProvidersResponse), 0, soap_copy__ns1__GetInvalidationProvidersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetInvalidationProvidersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetInvalidationProvidersResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetInvalidationProvidersResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetInvalidationProvidersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetInvalidationProvidersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetInvalidationProvidersResponse * SOAP_FMAC4 soap_get__ns1__GetInvalidationProvidersResponse(struct soap *soap, _ns1__GetInvalidationProvidersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetInvalidationProvidersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetInvalidationProvidersResponse * SOAP_FMAC2 soap_instantiate__ns1__GetInvalidationProvidersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetInvalidationProvidersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetInvalidationProvidersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetInvalidationProvidersResponse);
		if (size)
			*size = sizeof(_ns1__GetInvalidationProvidersResponse);
		((_ns1__GetInvalidationProvidersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetInvalidationProvidersResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetInvalidationProvidersResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetInvalidationProvidersResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetInvalidationProvidersResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetInvalidationProvidersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetInvalidationProvidersResponse %p -> %p\n", q, p));
	*(_ns1__GetInvalidationProvidersResponse*)p = *(_ns1__GetInvalidationProvidersResponse*)q;
}

void _ns1__GetInvalidationProviders::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetInvalidationProviders::AgentCode = NULL;
	this->_ns1__GetInvalidationProviders::AgentUserName = NULL;
	this->_ns1__GetInvalidationProviders::AgentPwd = NULL;
	/* transient soap skipped */
}

void _ns1__GetInvalidationProviders::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetInvalidationProviders::AgentCode);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetInvalidationProviders::AgentUserName);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetInvalidationProviders::AgentPwd);
	/* transient soap skipped */
#endif
}

int _ns1__GetInvalidationProviders::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetInvalidationProviders(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetInvalidationProviders(struct soap *soap, const char *tag, int id, const _ns1__GetInvalidationProviders *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetInvalidationProviders), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AgentCode", -1, &(a->_ns1__GetInvalidationProviders::AgentCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AgentUserName", -1, &(a->_ns1__GetInvalidationProviders::AgentUserName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AgentPwd", -1, &(a->_ns1__GetInvalidationProviders::AgentPwd), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetInvalidationProviders::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetInvalidationProviders(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetInvalidationProviders * SOAP_FMAC4 soap_in__ns1__GetInvalidationProviders(struct soap *soap, const char *tag, _ns1__GetInvalidationProviders *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetInvalidationProviders *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetInvalidationProviders, sizeof(_ns1__GetInvalidationProviders), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetInvalidationProviders)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetInvalidationProviders *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AgentCode1 = 1;
	size_t soap_flag_AgentUserName1 = 1;
	size_t soap_flag_AgentPwd1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AgentCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AgentCode", &(a->_ns1__GetInvalidationProviders::AgentCode), "xsd:string"))
				{	soap_flag_AgentCode1--;
					continue;
				}
			if (soap_flag_AgentUserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AgentUserName", &(a->_ns1__GetInvalidationProviders::AgentUserName), "xsd:string"))
				{	soap_flag_AgentUserName1--;
					continue;
				}
			if (soap_flag_AgentPwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AgentPwd", &(a->_ns1__GetInvalidationProviders::AgentPwd), "xsd:string"))
				{	soap_flag_AgentPwd1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetInvalidationProviders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetInvalidationProviders, 0, sizeof(_ns1__GetInvalidationProviders), 0, soap_copy__ns1__GetInvalidationProviders);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetInvalidationProviders::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetInvalidationProviders);
	if (this->soap_out(soap, tag?tag:"ns1:GetInvalidationProviders", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetInvalidationProviders::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetInvalidationProviders(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetInvalidationProviders * SOAP_FMAC4 soap_get__ns1__GetInvalidationProviders(struct soap *soap, _ns1__GetInvalidationProviders *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetInvalidationProviders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetInvalidationProviders * SOAP_FMAC2 soap_instantiate__ns1__GetInvalidationProviders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetInvalidationProviders(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetInvalidationProviders, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetInvalidationProviders);
		if (size)
			*size = sizeof(_ns1__GetInvalidationProviders);
		((_ns1__GetInvalidationProviders*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetInvalidationProviders, n);
		if (size)
			*size = n * sizeof(_ns1__GetInvalidationProviders);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetInvalidationProviders*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetInvalidationProviders*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetInvalidationProviders(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetInvalidationProviders %p -> %p\n", q, p));
	*(_ns1__GetInvalidationProviders*)p = *(_ns1__GetInvalidationProviders*)q;
}

void _ns1__GetOrderInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetOrderInfoResponse::GetOrderInfoResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetOrderInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetOrderInfoResponse::GetOrderInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetOrderInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetOrderInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetOrderInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetOrderInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetOrderInfoResponse), type))
		return soap->error;
	if (a->GetOrderInfoResult)
		soap_element_result(soap, "ns1:GetOrderInfoResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetOrderInfoResult", -1, &(a->_ns1__GetOrderInfoResponse::GetOrderInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetOrderInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetOrderInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetOrderInfoResponse * SOAP_FMAC4 soap_in__ns1__GetOrderInfoResponse(struct soap *soap, const char *tag, _ns1__GetOrderInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetOrderInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetOrderInfoResponse, sizeof(_ns1__GetOrderInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetOrderInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetOrderInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetOrderInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetOrderInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:GetOrderInfoResult", &(a->_ns1__GetOrderInfoResponse::GetOrderInfoResult), "xsd:string"))
				{	soap_flag_GetOrderInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetOrderInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetOrderInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetOrderInfoResponse, 0, sizeof(_ns1__GetOrderInfoResponse), 0, soap_copy__ns1__GetOrderInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetOrderInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetOrderInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetOrderInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetOrderInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetOrderInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetOrderInfoResponse * SOAP_FMAC4 soap_get__ns1__GetOrderInfoResponse(struct soap *soap, _ns1__GetOrderInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetOrderInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetOrderInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetOrderInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetOrderInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetOrderInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetOrderInfoResponse);
		if (size)
			*size = sizeof(_ns1__GetOrderInfoResponse);
		((_ns1__GetOrderInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetOrderInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetOrderInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetOrderInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetOrderInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetOrderInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetOrderInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetOrderInfoResponse*)p = *(_ns1__GetOrderInfoResponse*)q;
}

void _ns1__GetOrderInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetOrderInfo::AgentCode = NULL;
	this->_ns1__GetOrderInfo::AgentUserName = NULL;
	this->_ns1__GetOrderInfo::AgentPwd = NULL;
	this->_ns1__GetOrderInfo::OrderID = NULL;
	/* transient soap skipped */
}

void _ns1__GetOrderInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetOrderInfo::AgentCode);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetOrderInfo::AgentUserName);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetOrderInfo::AgentPwd);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetOrderInfo::OrderID);
	/* transient soap skipped */
#endif
}

int _ns1__GetOrderInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetOrderInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetOrderInfo(struct soap *soap, const char *tag, int id, const _ns1__GetOrderInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetOrderInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AgentCode", -1, &(a->_ns1__GetOrderInfo::AgentCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AgentUserName", -1, &(a->_ns1__GetOrderInfo::AgentUserName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AgentPwd", -1, &(a->_ns1__GetOrderInfo::AgentPwd), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:OrderID", -1, &(a->_ns1__GetOrderInfo::OrderID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetOrderInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetOrderInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetOrderInfo * SOAP_FMAC4 soap_in__ns1__GetOrderInfo(struct soap *soap, const char *tag, _ns1__GetOrderInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetOrderInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetOrderInfo, sizeof(_ns1__GetOrderInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetOrderInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetOrderInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AgentCode1 = 1;
	size_t soap_flag_AgentUserName1 = 1;
	size_t soap_flag_AgentPwd1 = 1;
	size_t soap_flag_OrderID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AgentCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AgentCode", &(a->_ns1__GetOrderInfo::AgentCode), "xsd:string"))
				{	soap_flag_AgentCode1--;
					continue;
				}
			if (soap_flag_AgentUserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AgentUserName", &(a->_ns1__GetOrderInfo::AgentUserName), "xsd:string"))
				{	soap_flag_AgentUserName1--;
					continue;
				}
			if (soap_flag_AgentPwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AgentPwd", &(a->_ns1__GetOrderInfo::AgentPwd), "xsd:string"))
				{	soap_flag_AgentPwd1--;
					continue;
				}
			if (soap_flag_OrderID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:OrderID", &(a->_ns1__GetOrderInfo::OrderID), "xsd:string"))
				{	soap_flag_OrderID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetOrderInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetOrderInfo, 0, sizeof(_ns1__GetOrderInfo), 0, soap_copy__ns1__GetOrderInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetOrderInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetOrderInfo);
	if (this->soap_out(soap, tag?tag:"ns1:GetOrderInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetOrderInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetOrderInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetOrderInfo * SOAP_FMAC4 soap_get__ns1__GetOrderInfo(struct soap *soap, _ns1__GetOrderInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetOrderInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetOrderInfo * SOAP_FMAC2 soap_instantiate__ns1__GetOrderInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetOrderInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetOrderInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetOrderInfo);
		if (size)
			*size = sizeof(_ns1__GetOrderInfo);
		((_ns1__GetOrderInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetOrderInfo, n);
		if (size)
			*size = n * sizeof(_ns1__GetOrderInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetOrderInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetOrderInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetOrderInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetOrderInfo %p -> %p\n", q, p));
	*(_ns1__GetOrderInfo*)p = *(_ns1__GetOrderInfo*)q;
}

void _ns1__RTCreateOrderResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__RTCreateOrderResponse::RTCreateOrderResult = NULL;
	/* transient soap skipped */
}

void _ns1__RTCreateOrderResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__RTCreateOrderResponse::RTCreateOrderResult);
	/* transient soap skipped */
#endif
}

int _ns1__RTCreateOrderResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RTCreateOrderResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RTCreateOrderResponse(struct soap *soap, const char *tag, int id, const _ns1__RTCreateOrderResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RTCreateOrderResponse), type))
		return soap->error;
	if (a->RTCreateOrderResult)
		soap_element_result(soap, "ns1:RTCreateOrderResult");
	if (soap_out_PointerTostd__string(soap, "ns1:RTCreateOrderResult", -1, &(a->_ns1__RTCreateOrderResponse::RTCreateOrderResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__RTCreateOrderResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RTCreateOrderResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RTCreateOrderResponse * SOAP_FMAC4 soap_in__ns1__RTCreateOrderResponse(struct soap *soap, const char *tag, _ns1__RTCreateOrderResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RTCreateOrderResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RTCreateOrderResponse, sizeof(_ns1__RTCreateOrderResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__RTCreateOrderResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__RTCreateOrderResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RTCreateOrderResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RTCreateOrderResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:RTCreateOrderResult", &(a->_ns1__RTCreateOrderResponse::RTCreateOrderResult), "xsd:string"))
				{	soap_flag_RTCreateOrderResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:RTCreateOrderResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RTCreateOrderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RTCreateOrderResponse, 0, sizeof(_ns1__RTCreateOrderResponse), 0, soap_copy__ns1__RTCreateOrderResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__RTCreateOrderResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__RTCreateOrderResponse);
	if (this->soap_out(soap, tag?tag:"ns1:RTCreateOrderResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RTCreateOrderResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RTCreateOrderResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RTCreateOrderResponse * SOAP_FMAC4 soap_get__ns1__RTCreateOrderResponse(struct soap *soap, _ns1__RTCreateOrderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RTCreateOrderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__RTCreateOrderResponse * SOAP_FMAC2 soap_instantiate__ns1__RTCreateOrderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RTCreateOrderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__RTCreateOrderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RTCreateOrderResponse);
		if (size)
			*size = sizeof(_ns1__RTCreateOrderResponse);
		((_ns1__RTCreateOrderResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__RTCreateOrderResponse, n);
		if (size)
			*size = n * sizeof(_ns1__RTCreateOrderResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__RTCreateOrderResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__RTCreateOrderResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__RTCreateOrderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__RTCreateOrderResponse %p -> %p\n", q, p));
	*(_ns1__RTCreateOrderResponse*)p = *(_ns1__RTCreateOrderResponse*)q;
}

void _ns1__RTCreateOrder::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__RTCreateOrder::xmlDoc = NULL;
	/* transient soap skipped */
}

void _ns1__RTCreateOrder::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__RTCreateOrder::xmlDoc);
	/* transient soap skipped */
#endif
}

int _ns1__RTCreateOrder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RTCreateOrder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RTCreateOrder(struct soap *soap, const char *tag, int id, const _ns1__RTCreateOrder *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RTCreateOrder), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:xmlDoc", -1, &(a->_ns1__RTCreateOrder::xmlDoc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__RTCreateOrder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RTCreateOrder(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RTCreateOrder * SOAP_FMAC4 soap_in__ns1__RTCreateOrder(struct soap *soap, const char *tag, _ns1__RTCreateOrder *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RTCreateOrder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RTCreateOrder, sizeof(_ns1__RTCreateOrder), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__RTCreateOrder)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__RTCreateOrder *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlDoc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlDoc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:xmlDoc", &(a->_ns1__RTCreateOrder::xmlDoc), "xsd:string"))
				{	soap_flag_xmlDoc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RTCreateOrder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RTCreateOrder, 0, sizeof(_ns1__RTCreateOrder), 0, soap_copy__ns1__RTCreateOrder);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__RTCreateOrder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__RTCreateOrder);
	if (this->soap_out(soap, tag?tag:"ns1:RTCreateOrder", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RTCreateOrder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RTCreateOrder(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RTCreateOrder * SOAP_FMAC4 soap_get__ns1__RTCreateOrder(struct soap *soap, _ns1__RTCreateOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RTCreateOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__RTCreateOrder * SOAP_FMAC2 soap_instantiate__ns1__RTCreateOrder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RTCreateOrder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__RTCreateOrder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RTCreateOrder);
		if (size)
			*size = sizeof(_ns1__RTCreateOrder);
		((_ns1__RTCreateOrder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__RTCreateOrder, n);
		if (size)
			*size = n * sizeof(_ns1__RTCreateOrder);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__RTCreateOrder*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__RTCreateOrder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__RTCreateOrder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__RTCreateOrder %p -> %p\n", q, p));
	*(_ns1__RTCreateOrder*)p = *(_ns1__RTCreateOrder*)q;
}

void _ns1__DetailCreateOrderResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__DetailCreateOrderResponse::DetailCreateOrderResult = NULL;
	/* transient soap skipped */
}

void _ns1__DetailCreateOrderResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__DetailCreateOrderResponse::DetailCreateOrderResult);
	/* transient soap skipped */
#endif
}

int _ns1__DetailCreateOrderResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DetailCreateOrderResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DetailCreateOrderResponse(struct soap *soap, const char *tag, int id, const _ns1__DetailCreateOrderResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DetailCreateOrderResponse), type))
		return soap->error;
	if (a->DetailCreateOrderResult)
		soap_element_result(soap, "ns1:DetailCreateOrderResult");
	if (soap_out_PointerTostd__string(soap, "ns1:DetailCreateOrderResult", -1, &(a->_ns1__DetailCreateOrderResponse::DetailCreateOrderResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DetailCreateOrderResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DetailCreateOrderResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DetailCreateOrderResponse * SOAP_FMAC4 soap_in__ns1__DetailCreateOrderResponse(struct soap *soap, const char *tag, _ns1__DetailCreateOrderResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DetailCreateOrderResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DetailCreateOrderResponse, sizeof(_ns1__DetailCreateOrderResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DetailCreateOrderResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DetailCreateOrderResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DetailCreateOrderResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DetailCreateOrderResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:DetailCreateOrderResult", &(a->_ns1__DetailCreateOrderResponse::DetailCreateOrderResult), "xsd:string"))
				{	soap_flag_DetailCreateOrderResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:DetailCreateOrderResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DetailCreateOrderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DetailCreateOrderResponse, 0, sizeof(_ns1__DetailCreateOrderResponse), 0, soap_copy__ns1__DetailCreateOrderResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__DetailCreateOrderResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DetailCreateOrderResponse);
	if (this->soap_out(soap, tag?tag:"ns1:DetailCreateOrderResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DetailCreateOrderResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DetailCreateOrderResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DetailCreateOrderResponse * SOAP_FMAC4 soap_get__ns1__DetailCreateOrderResponse(struct soap *soap, _ns1__DetailCreateOrderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DetailCreateOrderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DetailCreateOrderResponse * SOAP_FMAC2 soap_instantiate__ns1__DetailCreateOrderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DetailCreateOrderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DetailCreateOrderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DetailCreateOrderResponse);
		if (size)
			*size = sizeof(_ns1__DetailCreateOrderResponse);
		((_ns1__DetailCreateOrderResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__DetailCreateOrderResponse, n);
		if (size)
			*size = n * sizeof(_ns1__DetailCreateOrderResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__DetailCreateOrderResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__DetailCreateOrderResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DetailCreateOrderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DetailCreateOrderResponse %p -> %p\n", q, p));
	*(_ns1__DetailCreateOrderResponse*)p = *(_ns1__DetailCreateOrderResponse*)q;
}

void _ns1__DetailCreateOrder::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__DetailCreateOrder::xmlDoc = NULL;
	/* transient soap skipped */
}

void _ns1__DetailCreateOrder::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__DetailCreateOrder::xmlDoc);
	/* transient soap skipped */
#endif
}

int _ns1__DetailCreateOrder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DetailCreateOrder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DetailCreateOrder(struct soap *soap, const char *tag, int id, const _ns1__DetailCreateOrder *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DetailCreateOrder), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:xmlDoc", -1, &(a->_ns1__DetailCreateOrder::xmlDoc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DetailCreateOrder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DetailCreateOrder(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DetailCreateOrder * SOAP_FMAC4 soap_in__ns1__DetailCreateOrder(struct soap *soap, const char *tag, _ns1__DetailCreateOrder *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DetailCreateOrder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DetailCreateOrder, sizeof(_ns1__DetailCreateOrder), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DetailCreateOrder)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DetailCreateOrder *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlDoc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlDoc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:xmlDoc", &(a->_ns1__DetailCreateOrder::xmlDoc), "xsd:string"))
				{	soap_flag_xmlDoc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DetailCreateOrder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DetailCreateOrder, 0, sizeof(_ns1__DetailCreateOrder), 0, soap_copy__ns1__DetailCreateOrder);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__DetailCreateOrder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DetailCreateOrder);
	if (this->soap_out(soap, tag?tag:"ns1:DetailCreateOrder", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DetailCreateOrder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DetailCreateOrder(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DetailCreateOrder * SOAP_FMAC4 soap_get__ns1__DetailCreateOrder(struct soap *soap, _ns1__DetailCreateOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DetailCreateOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DetailCreateOrder * SOAP_FMAC2 soap_instantiate__ns1__DetailCreateOrder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DetailCreateOrder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DetailCreateOrder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DetailCreateOrder);
		if (size)
			*size = sizeof(_ns1__DetailCreateOrder);
		((_ns1__DetailCreateOrder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__DetailCreateOrder, n);
		if (size)
			*size = n * sizeof(_ns1__DetailCreateOrder);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__DetailCreateOrder*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__DetailCreateOrder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DetailCreateOrder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DetailCreateOrder %p -> %p\n", q, p));
	*(_ns1__DetailCreateOrder*)p = *(_ns1__DetailCreateOrder*)q;
}

void _ns1__GetDomesticMatchNormalZRateByIDResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetDomesticMatchNormalZRateByIDResponse::GetDomesticMatchNormalZRateByIDResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetDomesticMatchNormalZRateByIDResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetDomesticMatchNormalZRateByIDResponse::GetDomesticMatchNormalZRateByIDResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetDomesticMatchNormalZRateByIDResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDomesticMatchNormalZRateByIDResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDomesticMatchNormalZRateByIDResponse(struct soap *soap, const char *tag, int id, const _ns1__GetDomesticMatchNormalZRateByIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByIDResponse), type))
		return soap->error;
	if (a->GetDomesticMatchNormalZRateByIDResult)
		soap_element_result(soap, "ns1:GetDomesticMatchNormalZRateByIDResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetDomesticMatchNormalZRateByIDResult", -1, &(a->_ns1__GetDomesticMatchNormalZRateByIDResponse::GetDomesticMatchNormalZRateByIDResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDomesticMatchNormalZRateByIDResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDomesticMatchNormalZRateByIDResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDomesticMatchNormalZRateByIDResponse * SOAP_FMAC4 soap_in__ns1__GetDomesticMatchNormalZRateByIDResponse(struct soap *soap, const char *tag, _ns1__GetDomesticMatchNormalZRateByIDResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDomesticMatchNormalZRateByIDResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByIDResponse, sizeof(_ns1__GetDomesticMatchNormalZRateByIDResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByIDResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetDomesticMatchNormalZRateByIDResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetDomesticMatchNormalZRateByIDResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDomesticMatchNormalZRateByIDResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:GetDomesticMatchNormalZRateByIDResult", &(a->_ns1__GetDomesticMatchNormalZRateByIDResponse::GetDomesticMatchNormalZRateByIDResult), "xsd:string"))
				{	soap_flag_GetDomesticMatchNormalZRateByIDResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetDomesticMatchNormalZRateByIDResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDomesticMatchNormalZRateByIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByIDResponse, 0, sizeof(_ns1__GetDomesticMatchNormalZRateByIDResponse), 0, soap_copy__ns1__GetDomesticMatchNormalZRateByIDResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetDomesticMatchNormalZRateByIDResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByIDResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetDomesticMatchNormalZRateByIDResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDomesticMatchNormalZRateByIDResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDomesticMatchNormalZRateByIDResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDomesticMatchNormalZRateByIDResponse * SOAP_FMAC4 soap_get__ns1__GetDomesticMatchNormalZRateByIDResponse(struct soap *soap, _ns1__GetDomesticMatchNormalZRateByIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDomesticMatchNormalZRateByIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetDomesticMatchNormalZRateByIDResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDomesticMatchNormalZRateByIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDomesticMatchNormalZRateByIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetDomesticMatchNormalZRateByIDResponse);
		if (size)
			*size = sizeof(_ns1__GetDomesticMatchNormalZRateByIDResponse);
		((_ns1__GetDomesticMatchNormalZRateByIDResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetDomesticMatchNormalZRateByIDResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetDomesticMatchNormalZRateByIDResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetDomesticMatchNormalZRateByIDResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetDomesticMatchNormalZRateByIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetDomesticMatchNormalZRateByIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetDomesticMatchNormalZRateByIDResponse %p -> %p\n", q, p));
	*(_ns1__GetDomesticMatchNormalZRateByIDResponse*)p = *(_ns1__GetDomesticMatchNormalZRateByIDResponse*)q;
}

void _ns1__GetDomesticMatchNormalZRateByID::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetDomesticMatchNormalZRateByID::xmlDoc = NULL;
	/* transient soap skipped */
}

void _ns1__GetDomesticMatchNormalZRateByID::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetDomesticMatchNormalZRateByID::xmlDoc);
	/* transient soap skipped */
#endif
}

int _ns1__GetDomesticMatchNormalZRateByID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDomesticMatchNormalZRateByID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, const char *tag, int id, const _ns1__GetDomesticMatchNormalZRateByID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByID), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:xmlDoc", -1, &(a->_ns1__GetDomesticMatchNormalZRateByID::xmlDoc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDomesticMatchNormalZRateByID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDomesticMatchNormalZRateByID(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDomesticMatchNormalZRateByID * SOAP_FMAC4 soap_in__ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, const char *tag, _ns1__GetDomesticMatchNormalZRateByID *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDomesticMatchNormalZRateByID *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByID, sizeof(_ns1__GetDomesticMatchNormalZRateByID), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByID)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetDomesticMatchNormalZRateByID *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlDoc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlDoc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:xmlDoc", &(a->_ns1__GetDomesticMatchNormalZRateByID::xmlDoc), "xsd:string"))
				{	soap_flag_xmlDoc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDomesticMatchNormalZRateByID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByID, 0, sizeof(_ns1__GetDomesticMatchNormalZRateByID), 0, soap_copy__ns1__GetDomesticMatchNormalZRateByID);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetDomesticMatchNormalZRateByID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByID);
	if (this->soap_out(soap, tag?tag:"ns1:GetDomesticMatchNormalZRateByID", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDomesticMatchNormalZRateByID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDomesticMatchNormalZRateByID(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDomesticMatchNormalZRateByID * SOAP_FMAC4 soap_get__ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, _ns1__GetDomesticMatchNormalZRateByID *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDomesticMatchNormalZRateByID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetDomesticMatchNormalZRateByID * SOAP_FMAC2 soap_instantiate__ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDomesticMatchNormalZRateByID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetDomesticMatchNormalZRateByID);
		if (size)
			*size = sizeof(_ns1__GetDomesticMatchNormalZRateByID);
		((_ns1__GetDomesticMatchNormalZRateByID*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetDomesticMatchNormalZRateByID, n);
		if (size)
			*size = n * sizeof(_ns1__GetDomesticMatchNormalZRateByID);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetDomesticMatchNormalZRateByID*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetDomesticMatchNormalZRateByID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetDomesticMatchNormalZRateByID %p -> %p\n", q, p));
	*(_ns1__GetDomesticMatchNormalZRateByID*)p = *(_ns1__GetDomesticMatchNormalZRateByID*)q;
}

void _ns1__GetAVPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAVPolicyResponse::GetAVPolicyResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetAVPolicyResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAVPolicyResponse::GetAVPolicyResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetAVPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAVPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAVPolicyResponse(struct soap *soap, const char *tag, int id, const _ns1__GetAVPolicyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAVPolicyResponse), type))
		return soap->error;
	if (a->GetAVPolicyResult)
		soap_element_result(soap, "ns1:GetAVPolicyResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetAVPolicyResult", -1, &(a->_ns1__GetAVPolicyResponse::GetAVPolicyResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAVPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAVPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAVPolicyResponse * SOAP_FMAC4 soap_in__ns1__GetAVPolicyResponse(struct soap *soap, const char *tag, _ns1__GetAVPolicyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAVPolicyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAVPolicyResponse, sizeof(_ns1__GetAVPolicyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAVPolicyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAVPolicyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetAVPolicyResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAVPolicyResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:GetAVPolicyResult", &(a->_ns1__GetAVPolicyResponse::GetAVPolicyResult), "xsd:string"))
				{	soap_flag_GetAVPolicyResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetAVPolicyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAVPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAVPolicyResponse, 0, sizeof(_ns1__GetAVPolicyResponse), 0, soap_copy__ns1__GetAVPolicyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAVPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAVPolicyResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetAVPolicyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAVPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAVPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAVPolicyResponse * SOAP_FMAC4 soap_get__ns1__GetAVPolicyResponse(struct soap *soap, _ns1__GetAVPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAVPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAVPolicyResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAVPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAVPolicyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAVPolicyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAVPolicyResponse);
		if (size)
			*size = sizeof(_ns1__GetAVPolicyResponse);
		((_ns1__GetAVPolicyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetAVPolicyResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetAVPolicyResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetAVPolicyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetAVPolicyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAVPolicyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAVPolicyResponse %p -> %p\n", q, p));
	*(_ns1__GetAVPolicyResponse*)p = *(_ns1__GetAVPolicyResponse*)q;
}

void _ns1__GetAVPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAVPolicy::xmlDoc = NULL;
	/* transient soap skipped */
}

void _ns1__GetAVPolicy::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAVPolicy::xmlDoc);
	/* transient soap skipped */
#endif
}

int _ns1__GetAVPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAVPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAVPolicy(struct soap *soap, const char *tag, int id, const _ns1__GetAVPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAVPolicy), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:xmlDoc", -1, &(a->_ns1__GetAVPolicy::xmlDoc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAVPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAVPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAVPolicy * SOAP_FMAC4 soap_in__ns1__GetAVPolicy(struct soap *soap, const char *tag, _ns1__GetAVPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAVPolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAVPolicy, sizeof(_ns1__GetAVPolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAVPolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAVPolicy *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlDoc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlDoc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:xmlDoc", &(a->_ns1__GetAVPolicy::xmlDoc), "xsd:string"))
				{	soap_flag_xmlDoc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAVPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAVPolicy, 0, sizeof(_ns1__GetAVPolicy), 0, soap_copy__ns1__GetAVPolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAVPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAVPolicy);
	if (this->soap_out(soap, tag?tag:"ns1:GetAVPolicy", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAVPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAVPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAVPolicy * SOAP_FMAC4 soap_get__ns1__GetAVPolicy(struct soap *soap, _ns1__GetAVPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAVPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAVPolicy * SOAP_FMAC2 soap_instantiate__ns1__GetAVPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAVPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAVPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAVPolicy);
		if (size)
			*size = sizeof(_ns1__GetAVPolicy);
		((_ns1__GetAVPolicy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetAVPolicy, n);
		if (size)
			*size = n * sizeof(_ns1__GetAVPolicy);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetAVPolicy*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetAVPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAVPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAVPolicy %p -> %p\n", q, p));
	*(_ns1__GetAVPolicy*)p = *(_ns1__GetAVPolicy*)q;
}

void _ns1__MatchCommonPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__MatchCommonPolicyResponse::MatchCommonPolicyResult = NULL;
	/* transient soap skipped */
}

void _ns1__MatchCommonPolicyResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__MatchCommonPolicyResponse::MatchCommonPolicyResult);
	/* transient soap skipped */
#endif
}

int _ns1__MatchCommonPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MatchCommonPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MatchCommonPolicyResponse(struct soap *soap, const char *tag, int id, const _ns1__MatchCommonPolicyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__MatchCommonPolicyResponse), type))
		return soap->error;
	if (a->MatchCommonPolicyResult)
		soap_element_result(soap, "ns1:MatchCommonPolicyResult");
	if (soap_out_PointerTostd__string(soap, "ns1:MatchCommonPolicyResult", -1, &(a->_ns1__MatchCommonPolicyResponse::MatchCommonPolicyResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__MatchCommonPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__MatchCommonPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MatchCommonPolicyResponse * SOAP_FMAC4 soap_in__ns1__MatchCommonPolicyResponse(struct soap *soap, const char *tag, _ns1__MatchCommonPolicyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MatchCommonPolicyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__MatchCommonPolicyResponse, sizeof(_ns1__MatchCommonPolicyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__MatchCommonPolicyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__MatchCommonPolicyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_MatchCommonPolicyResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MatchCommonPolicyResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:MatchCommonPolicyResult", &(a->_ns1__MatchCommonPolicyResponse::MatchCommonPolicyResult), "xsd:string"))
				{	soap_flag_MatchCommonPolicyResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:MatchCommonPolicyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__MatchCommonPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__MatchCommonPolicyResponse, 0, sizeof(_ns1__MatchCommonPolicyResponse), 0, soap_copy__ns1__MatchCommonPolicyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__MatchCommonPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__MatchCommonPolicyResponse);
	if (this->soap_out(soap, tag?tag:"ns1:MatchCommonPolicyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__MatchCommonPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MatchCommonPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MatchCommonPolicyResponse * SOAP_FMAC4 soap_get__ns1__MatchCommonPolicyResponse(struct soap *soap, _ns1__MatchCommonPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MatchCommonPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__MatchCommonPolicyResponse * SOAP_FMAC2 soap_instantiate__ns1__MatchCommonPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MatchCommonPolicyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__MatchCommonPolicyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__MatchCommonPolicyResponse);
		if (size)
			*size = sizeof(_ns1__MatchCommonPolicyResponse);
		((_ns1__MatchCommonPolicyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__MatchCommonPolicyResponse, n);
		if (size)
			*size = n * sizeof(_ns1__MatchCommonPolicyResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__MatchCommonPolicyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__MatchCommonPolicyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__MatchCommonPolicyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__MatchCommonPolicyResponse %p -> %p\n", q, p));
	*(_ns1__MatchCommonPolicyResponse*)p = *(_ns1__MatchCommonPolicyResponse*)q;
}

void _ns1__MatchCommonPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__MatchCommonPolicy::xmlDoc = NULL;
	/* transient soap skipped */
}

void _ns1__MatchCommonPolicy::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__MatchCommonPolicy::xmlDoc);
	/* transient soap skipped */
#endif
}

int _ns1__MatchCommonPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MatchCommonPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MatchCommonPolicy(struct soap *soap, const char *tag, int id, const _ns1__MatchCommonPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__MatchCommonPolicy), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:xmlDoc", -1, &(a->_ns1__MatchCommonPolicy::xmlDoc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__MatchCommonPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__MatchCommonPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MatchCommonPolicy * SOAP_FMAC4 soap_in__ns1__MatchCommonPolicy(struct soap *soap, const char *tag, _ns1__MatchCommonPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MatchCommonPolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__MatchCommonPolicy, sizeof(_ns1__MatchCommonPolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__MatchCommonPolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__MatchCommonPolicy *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlDoc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlDoc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:xmlDoc", &(a->_ns1__MatchCommonPolicy::xmlDoc), "xsd:string"))
				{	soap_flag_xmlDoc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__MatchCommonPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__MatchCommonPolicy, 0, sizeof(_ns1__MatchCommonPolicy), 0, soap_copy__ns1__MatchCommonPolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__MatchCommonPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__MatchCommonPolicy);
	if (this->soap_out(soap, tag?tag:"ns1:MatchCommonPolicy", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__MatchCommonPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MatchCommonPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MatchCommonPolicy * SOAP_FMAC4 soap_get__ns1__MatchCommonPolicy(struct soap *soap, _ns1__MatchCommonPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MatchCommonPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__MatchCommonPolicy * SOAP_FMAC2 soap_instantiate__ns1__MatchCommonPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MatchCommonPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__MatchCommonPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__MatchCommonPolicy);
		if (size)
			*size = sizeof(_ns1__MatchCommonPolicy);
		((_ns1__MatchCommonPolicy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__MatchCommonPolicy, n);
		if (size)
			*size = n * sizeof(_ns1__MatchCommonPolicy);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__MatchCommonPolicy*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__MatchCommonPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__MatchCommonPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__MatchCommonPolicy %p -> %p\n", q, p));
	*(_ns1__MatchCommonPolicy*)p = *(_ns1__MatchCommonPolicy*)q;
}

void _ns1__GetAlterCommonPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAlterCommonPolicyResponse::GetAlterCommonPolicyResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetAlterCommonPolicyResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAlterCommonPolicyResponse::GetAlterCommonPolicyResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetAlterCommonPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAlterCommonPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAlterCommonPolicyResponse(struct soap *soap, const char *tag, int id, const _ns1__GetAlterCommonPolicyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAlterCommonPolicyResponse), type))
		return soap->error;
	if (a->GetAlterCommonPolicyResult)
		soap_element_result(soap, "ns1:GetAlterCommonPolicyResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetAlterCommonPolicyResult", -1, &(a->_ns1__GetAlterCommonPolicyResponse::GetAlterCommonPolicyResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAlterCommonPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAlterCommonPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAlterCommonPolicyResponse * SOAP_FMAC4 soap_in__ns1__GetAlterCommonPolicyResponse(struct soap *soap, const char *tag, _ns1__GetAlterCommonPolicyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAlterCommonPolicyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAlterCommonPolicyResponse, sizeof(_ns1__GetAlterCommonPolicyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAlterCommonPolicyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAlterCommonPolicyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetAlterCommonPolicyResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAlterCommonPolicyResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:GetAlterCommonPolicyResult", &(a->_ns1__GetAlterCommonPolicyResponse::GetAlterCommonPolicyResult), "xsd:string"))
				{	soap_flag_GetAlterCommonPolicyResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetAlterCommonPolicyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAlterCommonPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAlterCommonPolicyResponse, 0, sizeof(_ns1__GetAlterCommonPolicyResponse), 0, soap_copy__ns1__GetAlterCommonPolicyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAlterCommonPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAlterCommonPolicyResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetAlterCommonPolicyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAlterCommonPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAlterCommonPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAlterCommonPolicyResponse * SOAP_FMAC4 soap_get__ns1__GetAlterCommonPolicyResponse(struct soap *soap, _ns1__GetAlterCommonPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAlterCommonPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAlterCommonPolicyResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAlterCommonPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAlterCommonPolicyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAlterCommonPolicyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAlterCommonPolicyResponse);
		if (size)
			*size = sizeof(_ns1__GetAlterCommonPolicyResponse);
		((_ns1__GetAlterCommonPolicyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetAlterCommonPolicyResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetAlterCommonPolicyResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetAlterCommonPolicyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetAlterCommonPolicyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAlterCommonPolicyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAlterCommonPolicyResponse %p -> %p\n", q, p));
	*(_ns1__GetAlterCommonPolicyResponse*)p = *(_ns1__GetAlterCommonPolicyResponse*)q;
}

void _ns1__GetAlterCommonPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAlterCommonPolicy::tripType = NULL;
	this->_ns1__GetAlterCommonPolicy::ticketType = NULL;
	this->_ns1__GetAlterCommonPolicy::agentUserName = NULL;
	this->_ns1__GetAlterCommonPolicy::pwd = NULL;
	this->_ns1__GetAlterCommonPolicy::rQStartDateTime = NULL;
	/* transient soap skipped */
}

void _ns1__GetAlterCommonPolicy::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAlterCommonPolicy::tripType);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAlterCommonPolicy::ticketType);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAlterCommonPolicy::agentUserName);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAlterCommonPolicy::pwd);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAlterCommonPolicy::rQStartDateTime);
	/* transient soap skipped */
#endif
}

int _ns1__GetAlterCommonPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAlterCommonPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAlterCommonPolicy(struct soap *soap, const char *tag, int id, const _ns1__GetAlterCommonPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAlterCommonPolicy), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:tripType", -1, &(a->_ns1__GetAlterCommonPolicy::tripType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ticketType", -1, &(a->_ns1__GetAlterCommonPolicy::ticketType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:agentUserName", -1, &(a->_ns1__GetAlterCommonPolicy::agentUserName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:pwd", -1, &(a->_ns1__GetAlterCommonPolicy::pwd), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:rQStartDateTime", -1, &(a->_ns1__GetAlterCommonPolicy::rQStartDateTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAlterCommonPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAlterCommonPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAlterCommonPolicy * SOAP_FMAC4 soap_in__ns1__GetAlterCommonPolicy(struct soap *soap, const char *tag, _ns1__GetAlterCommonPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAlterCommonPolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAlterCommonPolicy, sizeof(_ns1__GetAlterCommonPolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAlterCommonPolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAlterCommonPolicy *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tripType1 = 1;
	size_t soap_flag_ticketType1 = 1;
	size_t soap_flag_agentUserName1 = 1;
	size_t soap_flag_pwd1 = 1;
	size_t soap_flag_rQStartDateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tripType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:tripType", &(a->_ns1__GetAlterCommonPolicy::tripType), "xsd:string"))
				{	soap_flag_tripType1--;
					continue;
				}
			if (soap_flag_ticketType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:ticketType", &(a->_ns1__GetAlterCommonPolicy::ticketType), "xsd:string"))
				{	soap_flag_ticketType1--;
					continue;
				}
			if (soap_flag_agentUserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:agentUserName", &(a->_ns1__GetAlterCommonPolicy::agentUserName), "xsd:string"))
				{	soap_flag_agentUserName1--;
					continue;
				}
			if (soap_flag_pwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:pwd", &(a->_ns1__GetAlterCommonPolicy::pwd), "xsd:string"))
				{	soap_flag_pwd1--;
					continue;
				}
			if (soap_flag_rQStartDateTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:rQStartDateTime", &(a->_ns1__GetAlterCommonPolicy::rQStartDateTime), "xsd:string"))
				{	soap_flag_rQStartDateTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAlterCommonPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAlterCommonPolicy, 0, sizeof(_ns1__GetAlterCommonPolicy), 0, soap_copy__ns1__GetAlterCommonPolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAlterCommonPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAlterCommonPolicy);
	if (this->soap_out(soap, tag?tag:"ns1:GetAlterCommonPolicy", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAlterCommonPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAlterCommonPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAlterCommonPolicy * SOAP_FMAC4 soap_get__ns1__GetAlterCommonPolicy(struct soap *soap, _ns1__GetAlterCommonPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAlterCommonPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAlterCommonPolicy * SOAP_FMAC2 soap_instantiate__ns1__GetAlterCommonPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAlterCommonPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAlterCommonPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAlterCommonPolicy);
		if (size)
			*size = sizeof(_ns1__GetAlterCommonPolicy);
		((_ns1__GetAlterCommonPolicy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetAlterCommonPolicy, n);
		if (size)
			*size = n * sizeof(_ns1__GetAlterCommonPolicy);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetAlterCommonPolicy*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetAlterCommonPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAlterCommonPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAlterCommonPolicy %p -> %p\n", q, p));
	*(_ns1__GetAlterCommonPolicy*)p = *(_ns1__GetAlterCommonPolicy*)q;
}

void _ns1__GetAllCommonPolicyZIPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAllCommonPolicyZIPResponse::GetAllCommonPolicyZIPResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetAllCommonPolicyZIPResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAllCommonPolicyZIPResponse::GetAllCommonPolicyZIPResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetAllCommonPolicyZIPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAllCommonPolicyZIPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAllCommonPolicyZIPResponse(struct soap *soap, const char *tag, int id, const _ns1__GetAllCommonPolicyZIPResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAllCommonPolicyZIPResponse), type))
		return soap->error;
	if (a->GetAllCommonPolicyZIPResult)
		soap_element_result(soap, "ns1:GetAllCommonPolicyZIPResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetAllCommonPolicyZIPResult", -1, &(a->_ns1__GetAllCommonPolicyZIPResponse::GetAllCommonPolicyZIPResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAllCommonPolicyZIPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAllCommonPolicyZIPResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAllCommonPolicyZIPResponse * SOAP_FMAC4 soap_in__ns1__GetAllCommonPolicyZIPResponse(struct soap *soap, const char *tag, _ns1__GetAllCommonPolicyZIPResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAllCommonPolicyZIPResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAllCommonPolicyZIPResponse, sizeof(_ns1__GetAllCommonPolicyZIPResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAllCommonPolicyZIPResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAllCommonPolicyZIPResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetAllCommonPolicyZIPResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAllCommonPolicyZIPResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:GetAllCommonPolicyZIPResult", &(a->_ns1__GetAllCommonPolicyZIPResponse::GetAllCommonPolicyZIPResult), "xsd:string"))
				{	soap_flag_GetAllCommonPolicyZIPResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetAllCommonPolicyZIPResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAllCommonPolicyZIPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAllCommonPolicyZIPResponse, 0, sizeof(_ns1__GetAllCommonPolicyZIPResponse), 0, soap_copy__ns1__GetAllCommonPolicyZIPResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAllCommonPolicyZIPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAllCommonPolicyZIPResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetAllCommonPolicyZIPResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAllCommonPolicyZIPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAllCommonPolicyZIPResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAllCommonPolicyZIPResponse * SOAP_FMAC4 soap_get__ns1__GetAllCommonPolicyZIPResponse(struct soap *soap, _ns1__GetAllCommonPolicyZIPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAllCommonPolicyZIPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAllCommonPolicyZIPResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAllCommonPolicyZIPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAllCommonPolicyZIPResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAllCommonPolicyZIPResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAllCommonPolicyZIPResponse);
		if (size)
			*size = sizeof(_ns1__GetAllCommonPolicyZIPResponse);
		((_ns1__GetAllCommonPolicyZIPResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetAllCommonPolicyZIPResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetAllCommonPolicyZIPResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetAllCommonPolicyZIPResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetAllCommonPolicyZIPResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAllCommonPolicyZIPResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAllCommonPolicyZIPResponse %p -> %p\n", q, p));
	*(_ns1__GetAllCommonPolicyZIPResponse*)p = *(_ns1__GetAllCommonPolicyZIPResponse*)q;
}

void _ns1__GetAllCommonPolicyZIP::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAllCommonPolicyZIP::tripType = NULL;
	this->_ns1__GetAllCommonPolicyZIP::ticketType = NULL;
	this->_ns1__GetAllCommonPolicyZIP::agentUserName = NULL;
	this->_ns1__GetAllCommonPolicyZIP::pwd = NULL;
	this->_ns1__GetAllCommonPolicyZIP::zip = NULL;
	/* transient soap skipped */
}

void _ns1__GetAllCommonPolicyZIP::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAllCommonPolicyZIP::tripType);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAllCommonPolicyZIP::ticketType);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAllCommonPolicyZIP::agentUserName);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAllCommonPolicyZIP::pwd);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAllCommonPolicyZIP::zip);
	/* transient soap skipped */
#endif
}

int _ns1__GetAllCommonPolicyZIP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAllCommonPolicyZIP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAllCommonPolicyZIP(struct soap *soap, const char *tag, int id, const _ns1__GetAllCommonPolicyZIP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAllCommonPolicyZIP), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:tripType", -1, &(a->_ns1__GetAllCommonPolicyZIP::tripType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ticketType", -1, &(a->_ns1__GetAllCommonPolicyZIP::ticketType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:agentUserName", -1, &(a->_ns1__GetAllCommonPolicyZIP::agentUserName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:pwd", -1, &(a->_ns1__GetAllCommonPolicyZIP::pwd), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:zip", -1, &(a->_ns1__GetAllCommonPolicyZIP::zip), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAllCommonPolicyZIP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAllCommonPolicyZIP(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAllCommonPolicyZIP * SOAP_FMAC4 soap_in__ns1__GetAllCommonPolicyZIP(struct soap *soap, const char *tag, _ns1__GetAllCommonPolicyZIP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAllCommonPolicyZIP *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAllCommonPolicyZIP, sizeof(_ns1__GetAllCommonPolicyZIP), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAllCommonPolicyZIP)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAllCommonPolicyZIP *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tripType1 = 1;
	size_t soap_flag_ticketType1 = 1;
	size_t soap_flag_agentUserName1 = 1;
	size_t soap_flag_pwd1 = 1;
	size_t soap_flag_zip1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tripType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:tripType", &(a->_ns1__GetAllCommonPolicyZIP::tripType), "xsd:string"))
				{	soap_flag_tripType1--;
					continue;
				}
			if (soap_flag_ticketType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:ticketType", &(a->_ns1__GetAllCommonPolicyZIP::ticketType), "xsd:string"))
				{	soap_flag_ticketType1--;
					continue;
				}
			if (soap_flag_agentUserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:agentUserName", &(a->_ns1__GetAllCommonPolicyZIP::agentUserName), "xsd:string"))
				{	soap_flag_agentUserName1--;
					continue;
				}
			if (soap_flag_pwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:pwd", &(a->_ns1__GetAllCommonPolicyZIP::pwd), "xsd:string"))
				{	soap_flag_pwd1--;
					continue;
				}
			if (soap_flag_zip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:zip", &(a->_ns1__GetAllCommonPolicyZIP::zip), "xsd:string"))
				{	soap_flag_zip1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAllCommonPolicyZIP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAllCommonPolicyZIP, 0, sizeof(_ns1__GetAllCommonPolicyZIP), 0, soap_copy__ns1__GetAllCommonPolicyZIP);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAllCommonPolicyZIP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAllCommonPolicyZIP);
	if (this->soap_out(soap, tag?tag:"ns1:GetAllCommonPolicyZIP", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAllCommonPolicyZIP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAllCommonPolicyZIP(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAllCommonPolicyZIP * SOAP_FMAC4 soap_get__ns1__GetAllCommonPolicyZIP(struct soap *soap, _ns1__GetAllCommonPolicyZIP *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAllCommonPolicyZIP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAllCommonPolicyZIP * SOAP_FMAC2 soap_instantiate__ns1__GetAllCommonPolicyZIP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAllCommonPolicyZIP(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAllCommonPolicyZIP, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAllCommonPolicyZIP);
		if (size)
			*size = sizeof(_ns1__GetAllCommonPolicyZIP);
		((_ns1__GetAllCommonPolicyZIP*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetAllCommonPolicyZIP, n);
		if (size)
			*size = n * sizeof(_ns1__GetAllCommonPolicyZIP);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetAllCommonPolicyZIP*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetAllCommonPolicyZIP*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAllCommonPolicyZIP(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAllCommonPolicyZIP %p -> %p\n", q, p));
	*(_ns1__GetAllCommonPolicyZIP*)p = *(_ns1__GetAllCommonPolicyZIP*)q;
}

void _ns1__GetAllCommonPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAllCommonPolicyResponse::GetAllCommonPolicyResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetAllCommonPolicyResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAllCommonPolicyResponse::GetAllCommonPolicyResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetAllCommonPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAllCommonPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAllCommonPolicyResponse(struct soap *soap, const char *tag, int id, const _ns1__GetAllCommonPolicyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAllCommonPolicyResponse), type))
		return soap->error;
	if (a->GetAllCommonPolicyResult)
		soap_element_result(soap, "ns1:GetAllCommonPolicyResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetAllCommonPolicyResult", -1, &(a->_ns1__GetAllCommonPolicyResponse::GetAllCommonPolicyResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAllCommonPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAllCommonPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAllCommonPolicyResponse * SOAP_FMAC4 soap_in__ns1__GetAllCommonPolicyResponse(struct soap *soap, const char *tag, _ns1__GetAllCommonPolicyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAllCommonPolicyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAllCommonPolicyResponse, sizeof(_ns1__GetAllCommonPolicyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAllCommonPolicyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAllCommonPolicyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetAllCommonPolicyResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAllCommonPolicyResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:GetAllCommonPolicyResult", &(a->_ns1__GetAllCommonPolicyResponse::GetAllCommonPolicyResult), "xsd:string"))
				{	soap_flag_GetAllCommonPolicyResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetAllCommonPolicyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAllCommonPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAllCommonPolicyResponse, 0, sizeof(_ns1__GetAllCommonPolicyResponse), 0, soap_copy__ns1__GetAllCommonPolicyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAllCommonPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAllCommonPolicyResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetAllCommonPolicyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAllCommonPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAllCommonPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAllCommonPolicyResponse * SOAP_FMAC4 soap_get__ns1__GetAllCommonPolicyResponse(struct soap *soap, _ns1__GetAllCommonPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAllCommonPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAllCommonPolicyResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAllCommonPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAllCommonPolicyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAllCommonPolicyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAllCommonPolicyResponse);
		if (size)
			*size = sizeof(_ns1__GetAllCommonPolicyResponse);
		((_ns1__GetAllCommonPolicyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetAllCommonPolicyResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetAllCommonPolicyResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetAllCommonPolicyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetAllCommonPolicyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAllCommonPolicyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAllCommonPolicyResponse %p -> %p\n", q, p));
	*(_ns1__GetAllCommonPolicyResponse*)p = *(_ns1__GetAllCommonPolicyResponse*)q;
}

void _ns1__GetAllCommonPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAllCommonPolicy::tripType = NULL;
	this->_ns1__GetAllCommonPolicy::ticketType = NULL;
	this->_ns1__GetAllCommonPolicy::agentUserName = NULL;
	this->_ns1__GetAllCommonPolicy::pwd = NULL;
	/* transient soap skipped */
}

void _ns1__GetAllCommonPolicy::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAllCommonPolicy::tripType);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAllCommonPolicy::ticketType);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAllCommonPolicy::agentUserName);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetAllCommonPolicy::pwd);
	/* transient soap skipped */
#endif
}

int _ns1__GetAllCommonPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAllCommonPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAllCommonPolicy(struct soap *soap, const char *tag, int id, const _ns1__GetAllCommonPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAllCommonPolicy), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:tripType", -1, &(a->_ns1__GetAllCommonPolicy::tripType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ticketType", -1, &(a->_ns1__GetAllCommonPolicy::ticketType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:agentUserName", -1, &(a->_ns1__GetAllCommonPolicy::agentUserName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:pwd", -1, &(a->_ns1__GetAllCommonPolicy::pwd), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAllCommonPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAllCommonPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAllCommonPolicy * SOAP_FMAC4 soap_in__ns1__GetAllCommonPolicy(struct soap *soap, const char *tag, _ns1__GetAllCommonPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAllCommonPolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAllCommonPolicy, sizeof(_ns1__GetAllCommonPolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAllCommonPolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAllCommonPolicy *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tripType1 = 1;
	size_t soap_flag_ticketType1 = 1;
	size_t soap_flag_agentUserName1 = 1;
	size_t soap_flag_pwd1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tripType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:tripType", &(a->_ns1__GetAllCommonPolicy::tripType), "xsd:string"))
				{	soap_flag_tripType1--;
					continue;
				}
			if (soap_flag_ticketType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:ticketType", &(a->_ns1__GetAllCommonPolicy::ticketType), "xsd:string"))
				{	soap_flag_ticketType1--;
					continue;
				}
			if (soap_flag_agentUserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:agentUserName", &(a->_ns1__GetAllCommonPolicy::agentUserName), "xsd:string"))
				{	soap_flag_agentUserName1--;
					continue;
				}
			if (soap_flag_pwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:pwd", &(a->_ns1__GetAllCommonPolicy::pwd), "xsd:string"))
				{	soap_flag_pwd1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAllCommonPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAllCommonPolicy, 0, sizeof(_ns1__GetAllCommonPolicy), 0, soap_copy__ns1__GetAllCommonPolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAllCommonPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAllCommonPolicy);
	if (this->soap_out(soap, tag?tag:"ns1:GetAllCommonPolicy", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAllCommonPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAllCommonPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAllCommonPolicy * SOAP_FMAC4 soap_get__ns1__GetAllCommonPolicy(struct soap *soap, _ns1__GetAllCommonPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAllCommonPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAllCommonPolicy * SOAP_FMAC2 soap_instantiate__ns1__GetAllCommonPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAllCommonPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAllCommonPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAllCommonPolicy);
		if (size)
			*size = sizeof(_ns1__GetAllCommonPolicy);
		((_ns1__GetAllCommonPolicy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetAllCommonPolicy, n);
		if (size)
			*size = n * sizeof(_ns1__GetAllCommonPolicy);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetAllCommonPolicy*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetAllCommonPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAllCommonPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAllCommonPolicy %p -> %p\n", q, p));
	*(_ns1__GetAllCommonPolicy*)p = *(_ns1__GetAllCommonPolicy*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetChangeFlightDate_(struct soap *soap, struct __ns1__GetChangeFlightDate_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetChangeFlightDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetChangeFlightDate_(struct soap *soap, const struct __ns1__GetChangeFlightDate_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetChangeFlightDate(soap, &a->ns1__GetChangeFlightDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetChangeFlightDate_(struct soap *soap, const char *tag, int id, const struct __ns1__GetChangeFlightDate_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetChangeFlightDate(soap, "ns1:GetChangeFlightDate", -1, &a->ns1__GetChangeFlightDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetChangeFlightDate_ * SOAP_FMAC4 soap_in___ns1__GetChangeFlightDate_(struct soap *soap, const char *tag, struct __ns1__GetChangeFlightDate_ *a, const char *type)
{
	size_t soap_flag_ns1__GetChangeFlightDate = 1;
	short soap_flag;
	a = (struct __ns1__GetChangeFlightDate_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetChangeFlightDate_, sizeof(struct __ns1__GetChangeFlightDate_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetChangeFlightDate_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetChangeFlightDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetChangeFlightDate(soap, "ns1:GetChangeFlightDate", &a->ns1__GetChangeFlightDate, ""))
				{	soap_flag_ns1__GetChangeFlightDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetChangeFlightDate_(struct soap *soap, const struct __ns1__GetChangeFlightDate_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetChangeFlightDate_(soap, tag?tag:"-ns1:GetChangeFlightDate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetChangeFlightDate_ * SOAP_FMAC4 soap_get___ns1__GetChangeFlightDate_(struct soap *soap, struct __ns1__GetChangeFlightDate_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetChangeFlightDate_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetChangeFlightDate_ * SOAP_FMAC2 soap_instantiate___ns1__GetChangeFlightDate_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetChangeFlightDate_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetChangeFlightDate_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetChangeFlightDate_);
		if (size)
			*size = sizeof(struct __ns1__GetChangeFlightDate_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetChangeFlightDate_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetChangeFlightDate_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetChangeFlightDate_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetChangeFlightDate_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetChangeFlightDate_ %p -> %p\n", q, p));
	*(struct __ns1__GetChangeFlightDate_*)p = *(struct __ns1__GetChangeFlightDate_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RefundOrder_(struct soap *soap, struct __ns1__RefundOrder_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RefundOrder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RefundOrder_(struct soap *soap, const struct __ns1__RefundOrder_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__RefundOrder(soap, &a->ns1__RefundOrder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RefundOrder_(struct soap *soap, const char *tag, int id, const struct __ns1__RefundOrder_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__RefundOrder(soap, "ns1:RefundOrder", -1, &a->ns1__RefundOrder, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RefundOrder_ * SOAP_FMAC4 soap_in___ns1__RefundOrder_(struct soap *soap, const char *tag, struct __ns1__RefundOrder_ *a, const char *type)
{
	size_t soap_flag_ns1__RefundOrder = 1;
	short soap_flag;
	a = (struct __ns1__RefundOrder_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__RefundOrder_, sizeof(struct __ns1__RefundOrder_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RefundOrder_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RefundOrder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RefundOrder(soap, "ns1:RefundOrder", &a->ns1__RefundOrder, ""))
				{	soap_flag_ns1__RefundOrder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RefundOrder_(struct soap *soap, const struct __ns1__RefundOrder_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__RefundOrder_(soap, tag?tag:"-ns1:RefundOrder", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RefundOrder_ * SOAP_FMAC4 soap_get___ns1__RefundOrder_(struct soap *soap, struct __ns1__RefundOrder_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RefundOrder_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__RefundOrder_ * SOAP_FMAC2 soap_instantiate___ns1__RefundOrder_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RefundOrder_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__RefundOrder_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__RefundOrder_);
		if (size)
			*size = sizeof(struct __ns1__RefundOrder_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__RefundOrder_, n);
		if (size)
			*size = n * sizeof(struct __ns1__RefundOrder_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__RefundOrder_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__RefundOrder_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__RefundOrder_ %p -> %p\n", q, p));
	*(struct __ns1__RefundOrder_*)p = *(struct __ns1__RefundOrder_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetInvalidationProviders_(struct soap *soap, struct __ns1__GetInvalidationProviders_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetInvalidationProviders = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetInvalidationProviders_(struct soap *soap, const struct __ns1__GetInvalidationProviders_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetInvalidationProviders(soap, &a->ns1__GetInvalidationProviders);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetInvalidationProviders_(struct soap *soap, const char *tag, int id, const struct __ns1__GetInvalidationProviders_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetInvalidationProviders(soap, "ns1:GetInvalidationProviders", -1, &a->ns1__GetInvalidationProviders, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInvalidationProviders_ * SOAP_FMAC4 soap_in___ns1__GetInvalidationProviders_(struct soap *soap, const char *tag, struct __ns1__GetInvalidationProviders_ *a, const char *type)
{
	size_t soap_flag_ns1__GetInvalidationProviders = 1;
	short soap_flag;
	a = (struct __ns1__GetInvalidationProviders_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetInvalidationProviders_, sizeof(struct __ns1__GetInvalidationProviders_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetInvalidationProviders_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetInvalidationProviders && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetInvalidationProviders(soap, "ns1:GetInvalidationProviders", &a->ns1__GetInvalidationProviders, ""))
				{	soap_flag_ns1__GetInvalidationProviders--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetInvalidationProviders_(struct soap *soap, const struct __ns1__GetInvalidationProviders_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetInvalidationProviders_(soap, tag?tag:"-ns1:GetInvalidationProviders", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInvalidationProviders_ * SOAP_FMAC4 soap_get___ns1__GetInvalidationProviders_(struct soap *soap, struct __ns1__GetInvalidationProviders_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetInvalidationProviders_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetInvalidationProviders_ * SOAP_FMAC2 soap_instantiate___ns1__GetInvalidationProviders_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetInvalidationProviders_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetInvalidationProviders_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetInvalidationProviders_);
		if (size)
			*size = sizeof(struct __ns1__GetInvalidationProviders_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetInvalidationProviders_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetInvalidationProviders_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetInvalidationProviders_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetInvalidationProviders_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetInvalidationProviders_ %p -> %p\n", q, p));
	*(struct __ns1__GetInvalidationProviders_*)p = *(struct __ns1__GetInvalidationProviders_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetOrderInfo_(struct soap *soap, struct __ns1__GetOrderInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetOrderInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetOrderInfo_(struct soap *soap, const struct __ns1__GetOrderInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetOrderInfo(soap, &a->ns1__GetOrderInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetOrderInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetOrderInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetOrderInfo(soap, "ns1:GetOrderInfo", -1, &a->ns1__GetOrderInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOrderInfo_ * SOAP_FMAC4 soap_in___ns1__GetOrderInfo_(struct soap *soap, const char *tag, struct __ns1__GetOrderInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetOrderInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetOrderInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetOrderInfo_, sizeof(struct __ns1__GetOrderInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetOrderInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetOrderInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetOrderInfo(soap, "ns1:GetOrderInfo", &a->ns1__GetOrderInfo, ""))
				{	soap_flag_ns1__GetOrderInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetOrderInfo_(struct soap *soap, const struct __ns1__GetOrderInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetOrderInfo_(soap, tag?tag:"-ns1:GetOrderInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOrderInfo_ * SOAP_FMAC4 soap_get___ns1__GetOrderInfo_(struct soap *soap, struct __ns1__GetOrderInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetOrderInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetOrderInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetOrderInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetOrderInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetOrderInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetOrderInfo_);
		if (size)
			*size = sizeof(struct __ns1__GetOrderInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetOrderInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetOrderInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetOrderInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetOrderInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetOrderInfo_ %p -> %p\n", q, p));
	*(struct __ns1__GetOrderInfo_*)p = *(struct __ns1__GetOrderInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RTCreateOrder_(struct soap *soap, struct __ns1__RTCreateOrder_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RTCreateOrder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RTCreateOrder_(struct soap *soap, const struct __ns1__RTCreateOrder_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__RTCreateOrder(soap, &a->ns1__RTCreateOrder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RTCreateOrder_(struct soap *soap, const char *tag, int id, const struct __ns1__RTCreateOrder_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__RTCreateOrder(soap, "ns1:RTCreateOrder", -1, &a->ns1__RTCreateOrder, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RTCreateOrder_ * SOAP_FMAC4 soap_in___ns1__RTCreateOrder_(struct soap *soap, const char *tag, struct __ns1__RTCreateOrder_ *a, const char *type)
{
	size_t soap_flag_ns1__RTCreateOrder = 1;
	short soap_flag;
	a = (struct __ns1__RTCreateOrder_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__RTCreateOrder_, sizeof(struct __ns1__RTCreateOrder_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RTCreateOrder_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RTCreateOrder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RTCreateOrder(soap, "ns1:RTCreateOrder", &a->ns1__RTCreateOrder, ""))
				{	soap_flag_ns1__RTCreateOrder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RTCreateOrder_(struct soap *soap, const struct __ns1__RTCreateOrder_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__RTCreateOrder_(soap, tag?tag:"-ns1:RTCreateOrder", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RTCreateOrder_ * SOAP_FMAC4 soap_get___ns1__RTCreateOrder_(struct soap *soap, struct __ns1__RTCreateOrder_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RTCreateOrder_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__RTCreateOrder_ * SOAP_FMAC2 soap_instantiate___ns1__RTCreateOrder_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RTCreateOrder_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__RTCreateOrder_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__RTCreateOrder_);
		if (size)
			*size = sizeof(struct __ns1__RTCreateOrder_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__RTCreateOrder_, n);
		if (size)
			*size = n * sizeof(struct __ns1__RTCreateOrder_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__RTCreateOrder_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__RTCreateOrder_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__RTCreateOrder_ %p -> %p\n", q, p));
	*(struct __ns1__RTCreateOrder_*)p = *(struct __ns1__RTCreateOrder_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DetailCreateOrder_(struct soap *soap, struct __ns1__DetailCreateOrder_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DetailCreateOrder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DetailCreateOrder_(struct soap *soap, const struct __ns1__DetailCreateOrder_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DetailCreateOrder(soap, &a->ns1__DetailCreateOrder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DetailCreateOrder_(struct soap *soap, const char *tag, int id, const struct __ns1__DetailCreateOrder_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__DetailCreateOrder(soap, "ns1:DetailCreateOrder", -1, &a->ns1__DetailCreateOrder, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DetailCreateOrder_ * SOAP_FMAC4 soap_in___ns1__DetailCreateOrder_(struct soap *soap, const char *tag, struct __ns1__DetailCreateOrder_ *a, const char *type)
{
	size_t soap_flag_ns1__DetailCreateOrder = 1;
	short soap_flag;
	a = (struct __ns1__DetailCreateOrder_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DetailCreateOrder_, sizeof(struct __ns1__DetailCreateOrder_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DetailCreateOrder_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DetailCreateOrder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DetailCreateOrder(soap, "ns1:DetailCreateOrder", &a->ns1__DetailCreateOrder, ""))
				{	soap_flag_ns1__DetailCreateOrder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DetailCreateOrder_(struct soap *soap, const struct __ns1__DetailCreateOrder_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__DetailCreateOrder_(soap, tag?tag:"-ns1:DetailCreateOrder", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DetailCreateOrder_ * SOAP_FMAC4 soap_get___ns1__DetailCreateOrder_(struct soap *soap, struct __ns1__DetailCreateOrder_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DetailCreateOrder_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__DetailCreateOrder_ * SOAP_FMAC2 soap_instantiate___ns1__DetailCreateOrder_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DetailCreateOrder_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__DetailCreateOrder_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__DetailCreateOrder_);
		if (size)
			*size = sizeof(struct __ns1__DetailCreateOrder_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__DetailCreateOrder_, n);
		if (size)
			*size = n * sizeof(struct __ns1__DetailCreateOrder_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__DetailCreateOrder_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__DetailCreateOrder_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__DetailCreateOrder_ %p -> %p\n", q, p));
	*(struct __ns1__DetailCreateOrder_*)p = *(struct __ns1__DetailCreateOrder_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDomesticMatchNormalZRateByID_(struct soap *soap, struct __ns1__GetDomesticMatchNormalZRateByID_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDomesticMatchNormalZRateByID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDomesticMatchNormalZRateByID_(struct soap *soap, const struct __ns1__GetDomesticMatchNormalZRateByID_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetDomesticMatchNormalZRateByID(soap, &a->ns1__GetDomesticMatchNormalZRateByID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDomesticMatchNormalZRateByID_(struct soap *soap, const char *tag, int id, const struct __ns1__GetDomesticMatchNormalZRateByID_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetDomesticMatchNormalZRateByID(soap, "ns1:GetDomesticMatchNormalZRateByID", -1, &a->ns1__GetDomesticMatchNormalZRateByID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDomesticMatchNormalZRateByID_ * SOAP_FMAC4 soap_in___ns1__GetDomesticMatchNormalZRateByID_(struct soap *soap, const char *tag, struct __ns1__GetDomesticMatchNormalZRateByID_ *a, const char *type)
{
	size_t soap_flag_ns1__GetDomesticMatchNormalZRateByID = 1;
	short soap_flag;
	a = (struct __ns1__GetDomesticMatchNormalZRateByID_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDomesticMatchNormalZRateByID_, sizeof(struct __ns1__GetDomesticMatchNormalZRateByID_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDomesticMatchNormalZRateByID_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDomesticMatchNormalZRateByID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetDomesticMatchNormalZRateByID(soap, "ns1:GetDomesticMatchNormalZRateByID", &a->ns1__GetDomesticMatchNormalZRateByID, ""))
				{	soap_flag_ns1__GetDomesticMatchNormalZRateByID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDomesticMatchNormalZRateByID_(struct soap *soap, const struct __ns1__GetDomesticMatchNormalZRateByID_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetDomesticMatchNormalZRateByID_(soap, tag?tag:"-ns1:GetDomesticMatchNormalZRateByID", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDomesticMatchNormalZRateByID_ * SOAP_FMAC4 soap_get___ns1__GetDomesticMatchNormalZRateByID_(struct soap *soap, struct __ns1__GetDomesticMatchNormalZRateByID_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDomesticMatchNormalZRateByID_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetDomesticMatchNormalZRateByID_ * SOAP_FMAC2 soap_instantiate___ns1__GetDomesticMatchNormalZRateByID_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDomesticMatchNormalZRateByID_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetDomesticMatchNormalZRateByID_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetDomesticMatchNormalZRateByID_);
		if (size)
			*size = sizeof(struct __ns1__GetDomesticMatchNormalZRateByID_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetDomesticMatchNormalZRateByID_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetDomesticMatchNormalZRateByID_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetDomesticMatchNormalZRateByID_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetDomesticMatchNormalZRateByID_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetDomesticMatchNormalZRateByID_ %p -> %p\n", q, p));
	*(struct __ns1__GetDomesticMatchNormalZRateByID_*)p = *(struct __ns1__GetDomesticMatchNormalZRateByID_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAVPolicy_(struct soap *soap, struct __ns1__GetAVPolicy_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAVPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAVPolicy_(struct soap *soap, const struct __ns1__GetAVPolicy_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAVPolicy(soap, &a->ns1__GetAVPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAVPolicy_(struct soap *soap, const char *tag, int id, const struct __ns1__GetAVPolicy_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetAVPolicy(soap, "ns1:GetAVPolicy", -1, &a->ns1__GetAVPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAVPolicy_ * SOAP_FMAC4 soap_in___ns1__GetAVPolicy_(struct soap *soap, const char *tag, struct __ns1__GetAVPolicy_ *a, const char *type)
{
	size_t soap_flag_ns1__GetAVPolicy = 1;
	short soap_flag;
	a = (struct __ns1__GetAVPolicy_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAVPolicy_, sizeof(struct __ns1__GetAVPolicy_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAVPolicy_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAVPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAVPolicy(soap, "ns1:GetAVPolicy", &a->ns1__GetAVPolicy, ""))
				{	soap_flag_ns1__GetAVPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAVPolicy_(struct soap *soap, const struct __ns1__GetAVPolicy_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAVPolicy_(soap, tag?tag:"-ns1:GetAVPolicy", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAVPolicy_ * SOAP_FMAC4 soap_get___ns1__GetAVPolicy_(struct soap *soap, struct __ns1__GetAVPolicy_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAVPolicy_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetAVPolicy_ * SOAP_FMAC2 soap_instantiate___ns1__GetAVPolicy_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAVPolicy_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAVPolicy_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetAVPolicy_);
		if (size)
			*size = sizeof(struct __ns1__GetAVPolicy_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetAVPolicy_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetAVPolicy_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetAVPolicy_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAVPolicy_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAVPolicy_ %p -> %p\n", q, p));
	*(struct __ns1__GetAVPolicy_*)p = *(struct __ns1__GetAVPolicy_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__MatchCommonPolicy_(struct soap *soap, struct __ns1__MatchCommonPolicy_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__MatchCommonPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__MatchCommonPolicy_(struct soap *soap, const struct __ns1__MatchCommonPolicy_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__MatchCommonPolicy(soap, &a->ns1__MatchCommonPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__MatchCommonPolicy_(struct soap *soap, const char *tag, int id, const struct __ns1__MatchCommonPolicy_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__MatchCommonPolicy(soap, "ns1:MatchCommonPolicy", -1, &a->ns1__MatchCommonPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MatchCommonPolicy_ * SOAP_FMAC4 soap_in___ns1__MatchCommonPolicy_(struct soap *soap, const char *tag, struct __ns1__MatchCommonPolicy_ *a, const char *type)
{
	size_t soap_flag_ns1__MatchCommonPolicy = 1;
	short soap_flag;
	a = (struct __ns1__MatchCommonPolicy_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__MatchCommonPolicy_, sizeof(struct __ns1__MatchCommonPolicy_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__MatchCommonPolicy_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__MatchCommonPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__MatchCommonPolicy(soap, "ns1:MatchCommonPolicy", &a->ns1__MatchCommonPolicy, ""))
				{	soap_flag_ns1__MatchCommonPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__MatchCommonPolicy_(struct soap *soap, const struct __ns1__MatchCommonPolicy_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__MatchCommonPolicy_(soap, tag?tag:"-ns1:MatchCommonPolicy", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MatchCommonPolicy_ * SOAP_FMAC4 soap_get___ns1__MatchCommonPolicy_(struct soap *soap, struct __ns1__MatchCommonPolicy_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__MatchCommonPolicy_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__MatchCommonPolicy_ * SOAP_FMAC2 soap_instantiate___ns1__MatchCommonPolicy_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__MatchCommonPolicy_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__MatchCommonPolicy_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__MatchCommonPolicy_);
		if (size)
			*size = sizeof(struct __ns1__MatchCommonPolicy_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__MatchCommonPolicy_, n);
		if (size)
			*size = n * sizeof(struct __ns1__MatchCommonPolicy_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__MatchCommonPolicy_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__MatchCommonPolicy_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__MatchCommonPolicy_ %p -> %p\n", q, p));
	*(struct __ns1__MatchCommonPolicy_*)p = *(struct __ns1__MatchCommonPolicy_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAlterCommonPolicy_(struct soap *soap, struct __ns1__GetAlterCommonPolicy_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAlterCommonPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAlterCommonPolicy_(struct soap *soap, const struct __ns1__GetAlterCommonPolicy_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAlterCommonPolicy(soap, &a->ns1__GetAlterCommonPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAlterCommonPolicy_(struct soap *soap, const char *tag, int id, const struct __ns1__GetAlterCommonPolicy_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetAlterCommonPolicy(soap, "ns1:GetAlterCommonPolicy", -1, &a->ns1__GetAlterCommonPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAlterCommonPolicy_ * SOAP_FMAC4 soap_in___ns1__GetAlterCommonPolicy_(struct soap *soap, const char *tag, struct __ns1__GetAlterCommonPolicy_ *a, const char *type)
{
	size_t soap_flag_ns1__GetAlterCommonPolicy = 1;
	short soap_flag;
	a = (struct __ns1__GetAlterCommonPolicy_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAlterCommonPolicy_, sizeof(struct __ns1__GetAlterCommonPolicy_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAlterCommonPolicy_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAlterCommonPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAlterCommonPolicy(soap, "ns1:GetAlterCommonPolicy", &a->ns1__GetAlterCommonPolicy, ""))
				{	soap_flag_ns1__GetAlterCommonPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAlterCommonPolicy_(struct soap *soap, const struct __ns1__GetAlterCommonPolicy_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAlterCommonPolicy_(soap, tag?tag:"-ns1:GetAlterCommonPolicy", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAlterCommonPolicy_ * SOAP_FMAC4 soap_get___ns1__GetAlterCommonPolicy_(struct soap *soap, struct __ns1__GetAlterCommonPolicy_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAlterCommonPolicy_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetAlterCommonPolicy_ * SOAP_FMAC2 soap_instantiate___ns1__GetAlterCommonPolicy_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAlterCommonPolicy_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAlterCommonPolicy_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetAlterCommonPolicy_);
		if (size)
			*size = sizeof(struct __ns1__GetAlterCommonPolicy_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetAlterCommonPolicy_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetAlterCommonPolicy_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetAlterCommonPolicy_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAlterCommonPolicy_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAlterCommonPolicy_ %p -> %p\n", q, p));
	*(struct __ns1__GetAlterCommonPolicy_*)p = *(struct __ns1__GetAlterCommonPolicy_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAllCommonPolicyZIP_(struct soap *soap, struct __ns1__GetAllCommonPolicyZIP_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAllCommonPolicyZIP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAllCommonPolicyZIP_(struct soap *soap, const struct __ns1__GetAllCommonPolicyZIP_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAllCommonPolicyZIP(soap, &a->ns1__GetAllCommonPolicyZIP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAllCommonPolicyZIP_(struct soap *soap, const char *tag, int id, const struct __ns1__GetAllCommonPolicyZIP_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetAllCommonPolicyZIP(soap, "ns1:GetAllCommonPolicyZIP", -1, &a->ns1__GetAllCommonPolicyZIP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAllCommonPolicyZIP_ * SOAP_FMAC4 soap_in___ns1__GetAllCommonPolicyZIP_(struct soap *soap, const char *tag, struct __ns1__GetAllCommonPolicyZIP_ *a, const char *type)
{
	size_t soap_flag_ns1__GetAllCommonPolicyZIP = 1;
	short soap_flag;
	a = (struct __ns1__GetAllCommonPolicyZIP_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAllCommonPolicyZIP_, sizeof(struct __ns1__GetAllCommonPolicyZIP_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAllCommonPolicyZIP_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAllCommonPolicyZIP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAllCommonPolicyZIP(soap, "ns1:GetAllCommonPolicyZIP", &a->ns1__GetAllCommonPolicyZIP, ""))
				{	soap_flag_ns1__GetAllCommonPolicyZIP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAllCommonPolicyZIP_(struct soap *soap, const struct __ns1__GetAllCommonPolicyZIP_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAllCommonPolicyZIP_(soap, tag?tag:"-ns1:GetAllCommonPolicyZIP", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAllCommonPolicyZIP_ * SOAP_FMAC4 soap_get___ns1__GetAllCommonPolicyZIP_(struct soap *soap, struct __ns1__GetAllCommonPolicyZIP_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAllCommonPolicyZIP_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetAllCommonPolicyZIP_ * SOAP_FMAC2 soap_instantiate___ns1__GetAllCommonPolicyZIP_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAllCommonPolicyZIP_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAllCommonPolicyZIP_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetAllCommonPolicyZIP_);
		if (size)
			*size = sizeof(struct __ns1__GetAllCommonPolicyZIP_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetAllCommonPolicyZIP_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetAllCommonPolicyZIP_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetAllCommonPolicyZIP_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAllCommonPolicyZIP_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAllCommonPolicyZIP_ %p -> %p\n", q, p));
	*(struct __ns1__GetAllCommonPolicyZIP_*)p = *(struct __ns1__GetAllCommonPolicyZIP_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAllCommonPolicy_(struct soap *soap, struct __ns1__GetAllCommonPolicy_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAllCommonPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAllCommonPolicy_(struct soap *soap, const struct __ns1__GetAllCommonPolicy_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAllCommonPolicy(soap, &a->ns1__GetAllCommonPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAllCommonPolicy_(struct soap *soap, const char *tag, int id, const struct __ns1__GetAllCommonPolicy_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetAllCommonPolicy(soap, "ns1:GetAllCommonPolicy", -1, &a->ns1__GetAllCommonPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAllCommonPolicy_ * SOAP_FMAC4 soap_in___ns1__GetAllCommonPolicy_(struct soap *soap, const char *tag, struct __ns1__GetAllCommonPolicy_ *a, const char *type)
{
	size_t soap_flag_ns1__GetAllCommonPolicy = 1;
	short soap_flag;
	a = (struct __ns1__GetAllCommonPolicy_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAllCommonPolicy_, sizeof(struct __ns1__GetAllCommonPolicy_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAllCommonPolicy_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAllCommonPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAllCommonPolicy(soap, "ns1:GetAllCommonPolicy", &a->ns1__GetAllCommonPolicy, ""))
				{	soap_flag_ns1__GetAllCommonPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAllCommonPolicy_(struct soap *soap, const struct __ns1__GetAllCommonPolicy_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAllCommonPolicy_(soap, tag?tag:"-ns1:GetAllCommonPolicy", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAllCommonPolicy_ * SOAP_FMAC4 soap_get___ns1__GetAllCommonPolicy_(struct soap *soap, struct __ns1__GetAllCommonPolicy_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAllCommonPolicy_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetAllCommonPolicy_ * SOAP_FMAC2 soap_instantiate___ns1__GetAllCommonPolicy_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAllCommonPolicy_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAllCommonPolicy_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetAllCommonPolicy_);
		if (size)
			*size = sizeof(struct __ns1__GetAllCommonPolicy_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetAllCommonPolicy_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetAllCommonPolicy_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetAllCommonPolicy_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAllCommonPolicy_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAllCommonPolicy_ %p -> %p\n", q, p));
	*(struct __ns1__GetAllCommonPolicy_*)p = *(struct __ns1__GetAllCommonPolicy_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetChangeFlightDate(struct soap *soap, struct __ns1__GetChangeFlightDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetChangeFlightDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetChangeFlightDate(struct soap *soap, const struct __ns1__GetChangeFlightDate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetChangeFlightDate(soap, &a->ns1__GetChangeFlightDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetChangeFlightDate(struct soap *soap, const char *tag, int id, const struct __ns1__GetChangeFlightDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetChangeFlightDate(soap, "ns1:GetChangeFlightDate", -1, &a->ns1__GetChangeFlightDate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetChangeFlightDate * SOAP_FMAC4 soap_in___ns1__GetChangeFlightDate(struct soap *soap, const char *tag, struct __ns1__GetChangeFlightDate *a, const char *type)
{
	size_t soap_flag_ns1__GetChangeFlightDate = 1;
	short soap_flag;
	a = (struct __ns1__GetChangeFlightDate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetChangeFlightDate, sizeof(struct __ns1__GetChangeFlightDate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetChangeFlightDate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetChangeFlightDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetChangeFlightDate(soap, "ns1:GetChangeFlightDate", &a->ns1__GetChangeFlightDate, ""))
				{	soap_flag_ns1__GetChangeFlightDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetChangeFlightDate(struct soap *soap, const struct __ns1__GetChangeFlightDate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetChangeFlightDate(soap, tag?tag:"-ns1:GetChangeFlightDate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetChangeFlightDate * SOAP_FMAC4 soap_get___ns1__GetChangeFlightDate(struct soap *soap, struct __ns1__GetChangeFlightDate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetChangeFlightDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetChangeFlightDate * SOAP_FMAC2 soap_instantiate___ns1__GetChangeFlightDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetChangeFlightDate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetChangeFlightDate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetChangeFlightDate);
		if (size)
			*size = sizeof(struct __ns1__GetChangeFlightDate);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetChangeFlightDate, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetChangeFlightDate);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetChangeFlightDate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetChangeFlightDate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetChangeFlightDate %p -> %p\n", q, p));
	*(struct __ns1__GetChangeFlightDate*)p = *(struct __ns1__GetChangeFlightDate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RefundOrder(struct soap *soap, struct __ns1__RefundOrder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RefundOrder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RefundOrder(struct soap *soap, const struct __ns1__RefundOrder *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__RefundOrder(soap, &a->ns1__RefundOrder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RefundOrder(struct soap *soap, const char *tag, int id, const struct __ns1__RefundOrder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__RefundOrder(soap, "ns1:RefundOrder", -1, &a->ns1__RefundOrder, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RefundOrder * SOAP_FMAC4 soap_in___ns1__RefundOrder(struct soap *soap, const char *tag, struct __ns1__RefundOrder *a, const char *type)
{
	size_t soap_flag_ns1__RefundOrder = 1;
	short soap_flag;
	a = (struct __ns1__RefundOrder *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__RefundOrder, sizeof(struct __ns1__RefundOrder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RefundOrder(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RefundOrder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RefundOrder(soap, "ns1:RefundOrder", &a->ns1__RefundOrder, ""))
				{	soap_flag_ns1__RefundOrder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RefundOrder(struct soap *soap, const struct __ns1__RefundOrder *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__RefundOrder(soap, tag?tag:"-ns1:RefundOrder", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RefundOrder * SOAP_FMAC4 soap_get___ns1__RefundOrder(struct soap *soap, struct __ns1__RefundOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RefundOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__RefundOrder * SOAP_FMAC2 soap_instantiate___ns1__RefundOrder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RefundOrder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__RefundOrder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__RefundOrder);
		if (size)
			*size = sizeof(struct __ns1__RefundOrder);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__RefundOrder, n);
		if (size)
			*size = n * sizeof(struct __ns1__RefundOrder);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__RefundOrder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__RefundOrder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__RefundOrder %p -> %p\n", q, p));
	*(struct __ns1__RefundOrder*)p = *(struct __ns1__RefundOrder*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetInvalidationProviders(struct soap *soap, struct __ns1__GetInvalidationProviders *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetInvalidationProviders = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetInvalidationProviders(struct soap *soap, const struct __ns1__GetInvalidationProviders *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetInvalidationProviders(soap, &a->ns1__GetInvalidationProviders);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetInvalidationProviders(struct soap *soap, const char *tag, int id, const struct __ns1__GetInvalidationProviders *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetInvalidationProviders(soap, "ns1:GetInvalidationProviders", -1, &a->ns1__GetInvalidationProviders, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInvalidationProviders * SOAP_FMAC4 soap_in___ns1__GetInvalidationProviders(struct soap *soap, const char *tag, struct __ns1__GetInvalidationProviders *a, const char *type)
{
	size_t soap_flag_ns1__GetInvalidationProviders = 1;
	short soap_flag;
	a = (struct __ns1__GetInvalidationProviders *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetInvalidationProviders, sizeof(struct __ns1__GetInvalidationProviders), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetInvalidationProviders(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetInvalidationProviders && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetInvalidationProviders(soap, "ns1:GetInvalidationProviders", &a->ns1__GetInvalidationProviders, ""))
				{	soap_flag_ns1__GetInvalidationProviders--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetInvalidationProviders(struct soap *soap, const struct __ns1__GetInvalidationProviders *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetInvalidationProviders(soap, tag?tag:"-ns1:GetInvalidationProviders", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetInvalidationProviders * SOAP_FMAC4 soap_get___ns1__GetInvalidationProviders(struct soap *soap, struct __ns1__GetInvalidationProviders *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetInvalidationProviders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetInvalidationProviders * SOAP_FMAC2 soap_instantiate___ns1__GetInvalidationProviders(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetInvalidationProviders(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetInvalidationProviders, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetInvalidationProviders);
		if (size)
			*size = sizeof(struct __ns1__GetInvalidationProviders);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetInvalidationProviders, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetInvalidationProviders);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetInvalidationProviders*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetInvalidationProviders(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetInvalidationProviders %p -> %p\n", q, p));
	*(struct __ns1__GetInvalidationProviders*)p = *(struct __ns1__GetInvalidationProviders*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetOrderInfo(struct soap *soap, struct __ns1__GetOrderInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetOrderInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetOrderInfo(struct soap *soap, const struct __ns1__GetOrderInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetOrderInfo(soap, &a->ns1__GetOrderInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetOrderInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetOrderInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetOrderInfo(soap, "ns1:GetOrderInfo", -1, &a->ns1__GetOrderInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOrderInfo * SOAP_FMAC4 soap_in___ns1__GetOrderInfo(struct soap *soap, const char *tag, struct __ns1__GetOrderInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetOrderInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetOrderInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetOrderInfo, sizeof(struct __ns1__GetOrderInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetOrderInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetOrderInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetOrderInfo(soap, "ns1:GetOrderInfo", &a->ns1__GetOrderInfo, ""))
				{	soap_flag_ns1__GetOrderInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetOrderInfo(struct soap *soap, const struct __ns1__GetOrderInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetOrderInfo(soap, tag?tag:"-ns1:GetOrderInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetOrderInfo * SOAP_FMAC4 soap_get___ns1__GetOrderInfo(struct soap *soap, struct __ns1__GetOrderInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetOrderInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetOrderInfo * SOAP_FMAC2 soap_instantiate___ns1__GetOrderInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetOrderInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetOrderInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetOrderInfo);
		if (size)
			*size = sizeof(struct __ns1__GetOrderInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetOrderInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetOrderInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetOrderInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetOrderInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetOrderInfo %p -> %p\n", q, p));
	*(struct __ns1__GetOrderInfo*)p = *(struct __ns1__GetOrderInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RTCreateOrder(struct soap *soap, struct __ns1__RTCreateOrder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RTCreateOrder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RTCreateOrder(struct soap *soap, const struct __ns1__RTCreateOrder *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__RTCreateOrder(soap, &a->ns1__RTCreateOrder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RTCreateOrder(struct soap *soap, const char *tag, int id, const struct __ns1__RTCreateOrder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__RTCreateOrder(soap, "ns1:RTCreateOrder", -1, &a->ns1__RTCreateOrder, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RTCreateOrder * SOAP_FMAC4 soap_in___ns1__RTCreateOrder(struct soap *soap, const char *tag, struct __ns1__RTCreateOrder *a, const char *type)
{
	size_t soap_flag_ns1__RTCreateOrder = 1;
	short soap_flag;
	a = (struct __ns1__RTCreateOrder *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__RTCreateOrder, sizeof(struct __ns1__RTCreateOrder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RTCreateOrder(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RTCreateOrder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RTCreateOrder(soap, "ns1:RTCreateOrder", &a->ns1__RTCreateOrder, ""))
				{	soap_flag_ns1__RTCreateOrder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RTCreateOrder(struct soap *soap, const struct __ns1__RTCreateOrder *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__RTCreateOrder(soap, tag?tag:"-ns1:RTCreateOrder", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RTCreateOrder * SOAP_FMAC4 soap_get___ns1__RTCreateOrder(struct soap *soap, struct __ns1__RTCreateOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RTCreateOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__RTCreateOrder * SOAP_FMAC2 soap_instantiate___ns1__RTCreateOrder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RTCreateOrder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__RTCreateOrder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__RTCreateOrder);
		if (size)
			*size = sizeof(struct __ns1__RTCreateOrder);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__RTCreateOrder, n);
		if (size)
			*size = n * sizeof(struct __ns1__RTCreateOrder);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__RTCreateOrder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__RTCreateOrder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__RTCreateOrder %p -> %p\n", q, p));
	*(struct __ns1__RTCreateOrder*)p = *(struct __ns1__RTCreateOrder*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DetailCreateOrder(struct soap *soap, struct __ns1__DetailCreateOrder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DetailCreateOrder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DetailCreateOrder(struct soap *soap, const struct __ns1__DetailCreateOrder *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DetailCreateOrder(soap, &a->ns1__DetailCreateOrder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DetailCreateOrder(struct soap *soap, const char *tag, int id, const struct __ns1__DetailCreateOrder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__DetailCreateOrder(soap, "ns1:DetailCreateOrder", -1, &a->ns1__DetailCreateOrder, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DetailCreateOrder * SOAP_FMAC4 soap_in___ns1__DetailCreateOrder(struct soap *soap, const char *tag, struct __ns1__DetailCreateOrder *a, const char *type)
{
	size_t soap_flag_ns1__DetailCreateOrder = 1;
	short soap_flag;
	a = (struct __ns1__DetailCreateOrder *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DetailCreateOrder, sizeof(struct __ns1__DetailCreateOrder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DetailCreateOrder(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DetailCreateOrder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DetailCreateOrder(soap, "ns1:DetailCreateOrder", &a->ns1__DetailCreateOrder, ""))
				{	soap_flag_ns1__DetailCreateOrder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DetailCreateOrder(struct soap *soap, const struct __ns1__DetailCreateOrder *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__DetailCreateOrder(soap, tag?tag:"-ns1:DetailCreateOrder", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DetailCreateOrder * SOAP_FMAC4 soap_get___ns1__DetailCreateOrder(struct soap *soap, struct __ns1__DetailCreateOrder *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DetailCreateOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__DetailCreateOrder * SOAP_FMAC2 soap_instantiate___ns1__DetailCreateOrder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DetailCreateOrder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__DetailCreateOrder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__DetailCreateOrder);
		if (size)
			*size = sizeof(struct __ns1__DetailCreateOrder);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__DetailCreateOrder, n);
		if (size)
			*size = n * sizeof(struct __ns1__DetailCreateOrder);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__DetailCreateOrder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__DetailCreateOrder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__DetailCreateOrder %p -> %p\n", q, p));
	*(struct __ns1__DetailCreateOrder*)p = *(struct __ns1__DetailCreateOrder*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, struct __ns1__GetDomesticMatchNormalZRateByID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDomesticMatchNormalZRateByID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, const struct __ns1__GetDomesticMatchNormalZRateByID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetDomesticMatchNormalZRateByID(soap, &a->ns1__GetDomesticMatchNormalZRateByID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, const char *tag, int id, const struct __ns1__GetDomesticMatchNormalZRateByID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetDomesticMatchNormalZRateByID(soap, "ns1:GetDomesticMatchNormalZRateByID", -1, &a->ns1__GetDomesticMatchNormalZRateByID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDomesticMatchNormalZRateByID * SOAP_FMAC4 soap_in___ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, const char *tag, struct __ns1__GetDomesticMatchNormalZRateByID *a, const char *type)
{
	size_t soap_flag_ns1__GetDomesticMatchNormalZRateByID = 1;
	short soap_flag;
	a = (struct __ns1__GetDomesticMatchNormalZRateByID *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDomesticMatchNormalZRateByID, sizeof(struct __ns1__GetDomesticMatchNormalZRateByID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDomesticMatchNormalZRateByID(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDomesticMatchNormalZRateByID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetDomesticMatchNormalZRateByID(soap, "ns1:GetDomesticMatchNormalZRateByID", &a->ns1__GetDomesticMatchNormalZRateByID, ""))
				{	soap_flag_ns1__GetDomesticMatchNormalZRateByID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, const struct __ns1__GetDomesticMatchNormalZRateByID *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetDomesticMatchNormalZRateByID(soap, tag?tag:"-ns1:GetDomesticMatchNormalZRateByID", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDomesticMatchNormalZRateByID * SOAP_FMAC4 soap_get___ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, struct __ns1__GetDomesticMatchNormalZRateByID *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDomesticMatchNormalZRateByID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetDomesticMatchNormalZRateByID * SOAP_FMAC2 soap_instantiate___ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDomesticMatchNormalZRateByID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetDomesticMatchNormalZRateByID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetDomesticMatchNormalZRateByID);
		if (size)
			*size = sizeof(struct __ns1__GetDomesticMatchNormalZRateByID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetDomesticMatchNormalZRateByID, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetDomesticMatchNormalZRateByID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetDomesticMatchNormalZRateByID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetDomesticMatchNormalZRateByID %p -> %p\n", q, p));
	*(struct __ns1__GetDomesticMatchNormalZRateByID*)p = *(struct __ns1__GetDomesticMatchNormalZRateByID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAVPolicy(struct soap *soap, struct __ns1__GetAVPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAVPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAVPolicy(struct soap *soap, const struct __ns1__GetAVPolicy *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAVPolicy(soap, &a->ns1__GetAVPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAVPolicy(struct soap *soap, const char *tag, int id, const struct __ns1__GetAVPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetAVPolicy(soap, "ns1:GetAVPolicy", -1, &a->ns1__GetAVPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAVPolicy * SOAP_FMAC4 soap_in___ns1__GetAVPolicy(struct soap *soap, const char *tag, struct __ns1__GetAVPolicy *a, const char *type)
{
	size_t soap_flag_ns1__GetAVPolicy = 1;
	short soap_flag;
	a = (struct __ns1__GetAVPolicy *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAVPolicy, sizeof(struct __ns1__GetAVPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAVPolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAVPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAVPolicy(soap, "ns1:GetAVPolicy", &a->ns1__GetAVPolicy, ""))
				{	soap_flag_ns1__GetAVPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAVPolicy(struct soap *soap, const struct __ns1__GetAVPolicy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAVPolicy(soap, tag?tag:"-ns1:GetAVPolicy", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAVPolicy * SOAP_FMAC4 soap_get___ns1__GetAVPolicy(struct soap *soap, struct __ns1__GetAVPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAVPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetAVPolicy * SOAP_FMAC2 soap_instantiate___ns1__GetAVPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAVPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAVPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetAVPolicy);
		if (size)
			*size = sizeof(struct __ns1__GetAVPolicy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetAVPolicy, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetAVPolicy);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetAVPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAVPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAVPolicy %p -> %p\n", q, p));
	*(struct __ns1__GetAVPolicy*)p = *(struct __ns1__GetAVPolicy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__MatchCommonPolicy(struct soap *soap, struct __ns1__MatchCommonPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__MatchCommonPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__MatchCommonPolicy(struct soap *soap, const struct __ns1__MatchCommonPolicy *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__MatchCommonPolicy(soap, &a->ns1__MatchCommonPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__MatchCommonPolicy(struct soap *soap, const char *tag, int id, const struct __ns1__MatchCommonPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__MatchCommonPolicy(soap, "ns1:MatchCommonPolicy", -1, &a->ns1__MatchCommonPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MatchCommonPolicy * SOAP_FMAC4 soap_in___ns1__MatchCommonPolicy(struct soap *soap, const char *tag, struct __ns1__MatchCommonPolicy *a, const char *type)
{
	size_t soap_flag_ns1__MatchCommonPolicy = 1;
	short soap_flag;
	a = (struct __ns1__MatchCommonPolicy *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__MatchCommonPolicy, sizeof(struct __ns1__MatchCommonPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__MatchCommonPolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__MatchCommonPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__MatchCommonPolicy(soap, "ns1:MatchCommonPolicy", &a->ns1__MatchCommonPolicy, ""))
				{	soap_flag_ns1__MatchCommonPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__MatchCommonPolicy(struct soap *soap, const struct __ns1__MatchCommonPolicy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__MatchCommonPolicy(soap, tag?tag:"-ns1:MatchCommonPolicy", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__MatchCommonPolicy * SOAP_FMAC4 soap_get___ns1__MatchCommonPolicy(struct soap *soap, struct __ns1__MatchCommonPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__MatchCommonPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__MatchCommonPolicy * SOAP_FMAC2 soap_instantiate___ns1__MatchCommonPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__MatchCommonPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__MatchCommonPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__MatchCommonPolicy);
		if (size)
			*size = sizeof(struct __ns1__MatchCommonPolicy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__MatchCommonPolicy, n);
		if (size)
			*size = n * sizeof(struct __ns1__MatchCommonPolicy);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__MatchCommonPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__MatchCommonPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__MatchCommonPolicy %p -> %p\n", q, p));
	*(struct __ns1__MatchCommonPolicy*)p = *(struct __ns1__MatchCommonPolicy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAlterCommonPolicy(struct soap *soap, struct __ns1__GetAlterCommonPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAlterCommonPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAlterCommonPolicy(struct soap *soap, const struct __ns1__GetAlterCommonPolicy *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAlterCommonPolicy(soap, &a->ns1__GetAlterCommonPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAlterCommonPolicy(struct soap *soap, const char *tag, int id, const struct __ns1__GetAlterCommonPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetAlterCommonPolicy(soap, "ns1:GetAlterCommonPolicy", -1, &a->ns1__GetAlterCommonPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAlterCommonPolicy * SOAP_FMAC4 soap_in___ns1__GetAlterCommonPolicy(struct soap *soap, const char *tag, struct __ns1__GetAlterCommonPolicy *a, const char *type)
{
	size_t soap_flag_ns1__GetAlterCommonPolicy = 1;
	short soap_flag;
	a = (struct __ns1__GetAlterCommonPolicy *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAlterCommonPolicy, sizeof(struct __ns1__GetAlterCommonPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAlterCommonPolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAlterCommonPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAlterCommonPolicy(soap, "ns1:GetAlterCommonPolicy", &a->ns1__GetAlterCommonPolicy, ""))
				{	soap_flag_ns1__GetAlterCommonPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAlterCommonPolicy(struct soap *soap, const struct __ns1__GetAlterCommonPolicy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAlterCommonPolicy(soap, tag?tag:"-ns1:GetAlterCommonPolicy", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAlterCommonPolicy * SOAP_FMAC4 soap_get___ns1__GetAlterCommonPolicy(struct soap *soap, struct __ns1__GetAlterCommonPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAlterCommonPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetAlterCommonPolicy * SOAP_FMAC2 soap_instantiate___ns1__GetAlterCommonPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAlterCommonPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAlterCommonPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetAlterCommonPolicy);
		if (size)
			*size = sizeof(struct __ns1__GetAlterCommonPolicy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetAlterCommonPolicy, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetAlterCommonPolicy);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetAlterCommonPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAlterCommonPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAlterCommonPolicy %p -> %p\n", q, p));
	*(struct __ns1__GetAlterCommonPolicy*)p = *(struct __ns1__GetAlterCommonPolicy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAllCommonPolicyZIP(struct soap *soap, struct __ns1__GetAllCommonPolicyZIP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAllCommonPolicyZIP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAllCommonPolicyZIP(struct soap *soap, const struct __ns1__GetAllCommonPolicyZIP *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAllCommonPolicyZIP(soap, &a->ns1__GetAllCommonPolicyZIP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAllCommonPolicyZIP(struct soap *soap, const char *tag, int id, const struct __ns1__GetAllCommonPolicyZIP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetAllCommonPolicyZIP(soap, "ns1:GetAllCommonPolicyZIP", -1, &a->ns1__GetAllCommonPolicyZIP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAllCommonPolicyZIP * SOAP_FMAC4 soap_in___ns1__GetAllCommonPolicyZIP(struct soap *soap, const char *tag, struct __ns1__GetAllCommonPolicyZIP *a, const char *type)
{
	size_t soap_flag_ns1__GetAllCommonPolicyZIP = 1;
	short soap_flag;
	a = (struct __ns1__GetAllCommonPolicyZIP *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAllCommonPolicyZIP, sizeof(struct __ns1__GetAllCommonPolicyZIP), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAllCommonPolicyZIP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAllCommonPolicyZIP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAllCommonPolicyZIP(soap, "ns1:GetAllCommonPolicyZIP", &a->ns1__GetAllCommonPolicyZIP, ""))
				{	soap_flag_ns1__GetAllCommonPolicyZIP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAllCommonPolicyZIP(struct soap *soap, const struct __ns1__GetAllCommonPolicyZIP *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAllCommonPolicyZIP(soap, tag?tag:"-ns1:GetAllCommonPolicyZIP", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAllCommonPolicyZIP * SOAP_FMAC4 soap_get___ns1__GetAllCommonPolicyZIP(struct soap *soap, struct __ns1__GetAllCommonPolicyZIP *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAllCommonPolicyZIP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetAllCommonPolicyZIP * SOAP_FMAC2 soap_instantiate___ns1__GetAllCommonPolicyZIP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAllCommonPolicyZIP(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAllCommonPolicyZIP, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetAllCommonPolicyZIP);
		if (size)
			*size = sizeof(struct __ns1__GetAllCommonPolicyZIP);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetAllCommonPolicyZIP, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetAllCommonPolicyZIP);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetAllCommonPolicyZIP*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAllCommonPolicyZIP(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAllCommonPolicyZIP %p -> %p\n", q, p));
	*(struct __ns1__GetAllCommonPolicyZIP*)p = *(struct __ns1__GetAllCommonPolicyZIP*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAllCommonPolicy(struct soap *soap, struct __ns1__GetAllCommonPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAllCommonPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAllCommonPolicy(struct soap *soap, const struct __ns1__GetAllCommonPolicy *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAllCommonPolicy(soap, &a->ns1__GetAllCommonPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAllCommonPolicy(struct soap *soap, const char *tag, int id, const struct __ns1__GetAllCommonPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetAllCommonPolicy(soap, "ns1:GetAllCommonPolicy", -1, &a->ns1__GetAllCommonPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAllCommonPolicy * SOAP_FMAC4 soap_in___ns1__GetAllCommonPolicy(struct soap *soap, const char *tag, struct __ns1__GetAllCommonPolicy *a, const char *type)
{
	size_t soap_flag_ns1__GetAllCommonPolicy = 1;
	short soap_flag;
	a = (struct __ns1__GetAllCommonPolicy *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAllCommonPolicy, sizeof(struct __ns1__GetAllCommonPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAllCommonPolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAllCommonPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAllCommonPolicy(soap, "ns1:GetAllCommonPolicy", &a->ns1__GetAllCommonPolicy, ""))
				{	soap_flag_ns1__GetAllCommonPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAllCommonPolicy(struct soap *soap, const struct __ns1__GetAllCommonPolicy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAllCommonPolicy(soap, tag?tag:"-ns1:GetAllCommonPolicy", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAllCommonPolicy * SOAP_FMAC4 soap_get___ns1__GetAllCommonPolicy(struct soap *soap, struct __ns1__GetAllCommonPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAllCommonPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetAllCommonPolicy * SOAP_FMAC2 soap_instantiate___ns1__GetAllCommonPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAllCommonPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAllCommonPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetAllCommonPolicy);
		if (size)
			*size = sizeof(struct __ns1__GetAllCommonPolicy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetAllCommonPolicy, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetAllCommonPolicy);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetAllCommonPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAllCommonPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAllCommonPolicy %p -> %p\n", q, p));
	*(struct __ns1__GetAllCommonPolicy*)p = *(struct __ns1__GetAllCommonPolicy*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetChangeFlightDateResponse(struct soap *soap, _ns1__GetChangeFlightDateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetChangeFlightDateResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetChangeFlightDateResponse(struct soap *soap, const char *tag, int id, _ns1__GetChangeFlightDateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetChangeFlightDateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetChangeFlightDateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetChangeFlightDateResponse(struct soap *soap, const char *tag, _ns1__GetChangeFlightDateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetChangeFlightDateResponse **)soap_malloc(soap, sizeof(_ns1__GetChangeFlightDateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetChangeFlightDateResponse *)soap_instantiate__ns1__GetChangeFlightDateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetChangeFlightDateResponse ** p = (_ns1__GetChangeFlightDateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetChangeFlightDateResponse, sizeof(_ns1__GetChangeFlightDateResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetChangeFlightDateResponse(struct soap *soap, _ns1__GetChangeFlightDateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetChangeFlightDateResponse);
	if (soap_out_PointerTo_ns1__GetChangeFlightDateResponse(soap, tag?tag:"ns1:GetChangeFlightDateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetChangeFlightDateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetChangeFlightDateResponse(struct soap *soap, _ns1__GetChangeFlightDateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetChangeFlightDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetChangeFlightDate(struct soap *soap, _ns1__GetChangeFlightDate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetChangeFlightDate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetChangeFlightDate(struct soap *soap, const char *tag, int id, _ns1__GetChangeFlightDate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetChangeFlightDate);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetChangeFlightDate ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetChangeFlightDate(struct soap *soap, const char *tag, _ns1__GetChangeFlightDate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetChangeFlightDate **)soap_malloc(soap, sizeof(_ns1__GetChangeFlightDate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetChangeFlightDate *)soap_instantiate__ns1__GetChangeFlightDate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetChangeFlightDate ** p = (_ns1__GetChangeFlightDate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetChangeFlightDate, sizeof(_ns1__GetChangeFlightDate), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetChangeFlightDate(struct soap *soap, _ns1__GetChangeFlightDate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetChangeFlightDate);
	if (soap_out_PointerTo_ns1__GetChangeFlightDate(soap, tag?tag:"ns1:GetChangeFlightDate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetChangeFlightDate ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetChangeFlightDate(struct soap *soap, _ns1__GetChangeFlightDate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetChangeFlightDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RefundOrderResponse(struct soap *soap, _ns1__RefundOrderResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RefundOrderResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RefundOrderResponse(struct soap *soap, const char *tag, int id, _ns1__RefundOrderResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RefundOrderResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RefundOrderResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__RefundOrderResponse(struct soap *soap, const char *tag, _ns1__RefundOrderResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RefundOrderResponse **)soap_malloc(soap, sizeof(_ns1__RefundOrderResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RefundOrderResponse *)soap_instantiate__ns1__RefundOrderResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__RefundOrderResponse ** p = (_ns1__RefundOrderResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RefundOrderResponse, sizeof(_ns1__RefundOrderResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RefundOrderResponse(struct soap *soap, _ns1__RefundOrderResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__RefundOrderResponse);
	if (soap_out_PointerTo_ns1__RefundOrderResponse(soap, tag?tag:"ns1:RefundOrderResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RefundOrderResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__RefundOrderResponse(struct soap *soap, _ns1__RefundOrderResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RefundOrderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RefundOrder(struct soap *soap, _ns1__RefundOrder *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RefundOrder))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RefundOrder(struct soap *soap, const char *tag, int id, _ns1__RefundOrder *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RefundOrder);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RefundOrder ** SOAP_FMAC4 soap_in_PointerTo_ns1__RefundOrder(struct soap *soap, const char *tag, _ns1__RefundOrder **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RefundOrder **)soap_malloc(soap, sizeof(_ns1__RefundOrder *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RefundOrder *)soap_instantiate__ns1__RefundOrder(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__RefundOrder ** p = (_ns1__RefundOrder **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RefundOrder, sizeof(_ns1__RefundOrder), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RefundOrder(struct soap *soap, _ns1__RefundOrder *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__RefundOrder);
	if (soap_out_PointerTo_ns1__RefundOrder(soap, tag?tag:"ns1:RefundOrder", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RefundOrder ** SOAP_FMAC4 soap_get_PointerTo_ns1__RefundOrder(struct soap *soap, _ns1__RefundOrder **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RefundOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetInvalidationProvidersResponse(struct soap *soap, _ns1__GetInvalidationProvidersResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetInvalidationProvidersResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetInvalidationProvidersResponse(struct soap *soap, const char *tag, int id, _ns1__GetInvalidationProvidersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetInvalidationProvidersResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetInvalidationProvidersResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetInvalidationProvidersResponse(struct soap *soap, const char *tag, _ns1__GetInvalidationProvidersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetInvalidationProvidersResponse **)soap_malloc(soap, sizeof(_ns1__GetInvalidationProvidersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetInvalidationProvidersResponse *)soap_instantiate__ns1__GetInvalidationProvidersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetInvalidationProvidersResponse ** p = (_ns1__GetInvalidationProvidersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetInvalidationProvidersResponse, sizeof(_ns1__GetInvalidationProvidersResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetInvalidationProvidersResponse(struct soap *soap, _ns1__GetInvalidationProvidersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetInvalidationProvidersResponse);
	if (soap_out_PointerTo_ns1__GetInvalidationProvidersResponse(soap, tag?tag:"ns1:GetInvalidationProvidersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetInvalidationProvidersResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetInvalidationProvidersResponse(struct soap *soap, _ns1__GetInvalidationProvidersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetInvalidationProvidersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetInvalidationProviders(struct soap *soap, _ns1__GetInvalidationProviders *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetInvalidationProviders))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetInvalidationProviders(struct soap *soap, const char *tag, int id, _ns1__GetInvalidationProviders *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetInvalidationProviders);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetInvalidationProviders ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetInvalidationProviders(struct soap *soap, const char *tag, _ns1__GetInvalidationProviders **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetInvalidationProviders **)soap_malloc(soap, sizeof(_ns1__GetInvalidationProviders *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetInvalidationProviders *)soap_instantiate__ns1__GetInvalidationProviders(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetInvalidationProviders ** p = (_ns1__GetInvalidationProviders **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetInvalidationProviders, sizeof(_ns1__GetInvalidationProviders), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetInvalidationProviders(struct soap *soap, _ns1__GetInvalidationProviders *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetInvalidationProviders);
	if (soap_out_PointerTo_ns1__GetInvalidationProviders(soap, tag?tag:"ns1:GetInvalidationProviders", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetInvalidationProviders ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetInvalidationProviders(struct soap *soap, _ns1__GetInvalidationProviders **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetInvalidationProviders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetOrderInfoResponse(struct soap *soap, _ns1__GetOrderInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetOrderInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetOrderInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetOrderInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetOrderInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetOrderInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetOrderInfoResponse(struct soap *soap, const char *tag, _ns1__GetOrderInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetOrderInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetOrderInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetOrderInfoResponse *)soap_instantiate__ns1__GetOrderInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetOrderInfoResponse ** p = (_ns1__GetOrderInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetOrderInfoResponse, sizeof(_ns1__GetOrderInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetOrderInfoResponse(struct soap *soap, _ns1__GetOrderInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetOrderInfoResponse);
	if (soap_out_PointerTo_ns1__GetOrderInfoResponse(soap, tag?tag:"ns1:GetOrderInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetOrderInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetOrderInfoResponse(struct soap *soap, _ns1__GetOrderInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetOrderInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetOrderInfo(struct soap *soap, _ns1__GetOrderInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetOrderInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetOrderInfo(struct soap *soap, const char *tag, int id, _ns1__GetOrderInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetOrderInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetOrderInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetOrderInfo(struct soap *soap, const char *tag, _ns1__GetOrderInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetOrderInfo **)soap_malloc(soap, sizeof(_ns1__GetOrderInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetOrderInfo *)soap_instantiate__ns1__GetOrderInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetOrderInfo ** p = (_ns1__GetOrderInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetOrderInfo, sizeof(_ns1__GetOrderInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetOrderInfo(struct soap *soap, _ns1__GetOrderInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetOrderInfo);
	if (soap_out_PointerTo_ns1__GetOrderInfo(soap, tag?tag:"ns1:GetOrderInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetOrderInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetOrderInfo(struct soap *soap, _ns1__GetOrderInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetOrderInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RTCreateOrderResponse(struct soap *soap, _ns1__RTCreateOrderResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RTCreateOrderResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RTCreateOrderResponse(struct soap *soap, const char *tag, int id, _ns1__RTCreateOrderResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RTCreateOrderResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RTCreateOrderResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__RTCreateOrderResponse(struct soap *soap, const char *tag, _ns1__RTCreateOrderResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RTCreateOrderResponse **)soap_malloc(soap, sizeof(_ns1__RTCreateOrderResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RTCreateOrderResponse *)soap_instantiate__ns1__RTCreateOrderResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__RTCreateOrderResponse ** p = (_ns1__RTCreateOrderResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RTCreateOrderResponse, sizeof(_ns1__RTCreateOrderResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RTCreateOrderResponse(struct soap *soap, _ns1__RTCreateOrderResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__RTCreateOrderResponse);
	if (soap_out_PointerTo_ns1__RTCreateOrderResponse(soap, tag?tag:"ns1:RTCreateOrderResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RTCreateOrderResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__RTCreateOrderResponse(struct soap *soap, _ns1__RTCreateOrderResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RTCreateOrderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RTCreateOrder(struct soap *soap, _ns1__RTCreateOrder *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RTCreateOrder))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RTCreateOrder(struct soap *soap, const char *tag, int id, _ns1__RTCreateOrder *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RTCreateOrder);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RTCreateOrder ** SOAP_FMAC4 soap_in_PointerTo_ns1__RTCreateOrder(struct soap *soap, const char *tag, _ns1__RTCreateOrder **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RTCreateOrder **)soap_malloc(soap, sizeof(_ns1__RTCreateOrder *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RTCreateOrder *)soap_instantiate__ns1__RTCreateOrder(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__RTCreateOrder ** p = (_ns1__RTCreateOrder **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RTCreateOrder, sizeof(_ns1__RTCreateOrder), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RTCreateOrder(struct soap *soap, _ns1__RTCreateOrder *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__RTCreateOrder);
	if (soap_out_PointerTo_ns1__RTCreateOrder(soap, tag?tag:"ns1:RTCreateOrder", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RTCreateOrder ** SOAP_FMAC4 soap_get_PointerTo_ns1__RTCreateOrder(struct soap *soap, _ns1__RTCreateOrder **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RTCreateOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DetailCreateOrderResponse(struct soap *soap, _ns1__DetailCreateOrderResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DetailCreateOrderResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DetailCreateOrderResponse(struct soap *soap, const char *tag, int id, _ns1__DetailCreateOrderResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DetailCreateOrderResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DetailCreateOrderResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__DetailCreateOrderResponse(struct soap *soap, const char *tag, _ns1__DetailCreateOrderResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DetailCreateOrderResponse **)soap_malloc(soap, sizeof(_ns1__DetailCreateOrderResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DetailCreateOrderResponse *)soap_instantiate__ns1__DetailCreateOrderResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DetailCreateOrderResponse ** p = (_ns1__DetailCreateOrderResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DetailCreateOrderResponse, sizeof(_ns1__DetailCreateOrderResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DetailCreateOrderResponse(struct soap *soap, _ns1__DetailCreateOrderResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DetailCreateOrderResponse);
	if (soap_out_PointerTo_ns1__DetailCreateOrderResponse(soap, tag?tag:"ns1:DetailCreateOrderResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DetailCreateOrderResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__DetailCreateOrderResponse(struct soap *soap, _ns1__DetailCreateOrderResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DetailCreateOrderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DetailCreateOrder(struct soap *soap, _ns1__DetailCreateOrder *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DetailCreateOrder))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DetailCreateOrder(struct soap *soap, const char *tag, int id, _ns1__DetailCreateOrder *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DetailCreateOrder);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DetailCreateOrder ** SOAP_FMAC4 soap_in_PointerTo_ns1__DetailCreateOrder(struct soap *soap, const char *tag, _ns1__DetailCreateOrder **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DetailCreateOrder **)soap_malloc(soap, sizeof(_ns1__DetailCreateOrder *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DetailCreateOrder *)soap_instantiate__ns1__DetailCreateOrder(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DetailCreateOrder ** p = (_ns1__DetailCreateOrder **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DetailCreateOrder, sizeof(_ns1__DetailCreateOrder), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DetailCreateOrder(struct soap *soap, _ns1__DetailCreateOrder *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DetailCreateOrder);
	if (soap_out_PointerTo_ns1__DetailCreateOrder(soap, tag?tag:"ns1:DetailCreateOrder", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DetailCreateOrder ** SOAP_FMAC4 soap_get_PointerTo_ns1__DetailCreateOrder(struct soap *soap, _ns1__DetailCreateOrder **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DetailCreateOrder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDomesticMatchNormalZRateByIDResponse(struct soap *soap, _ns1__GetDomesticMatchNormalZRateByIDResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByIDResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDomesticMatchNormalZRateByIDResponse(struct soap *soap, const char *tag, int id, _ns1__GetDomesticMatchNormalZRateByIDResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByIDResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetDomesticMatchNormalZRateByIDResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDomesticMatchNormalZRateByIDResponse(struct soap *soap, const char *tag, _ns1__GetDomesticMatchNormalZRateByIDResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDomesticMatchNormalZRateByIDResponse **)soap_malloc(soap, sizeof(_ns1__GetDomesticMatchNormalZRateByIDResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDomesticMatchNormalZRateByIDResponse *)soap_instantiate__ns1__GetDomesticMatchNormalZRateByIDResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetDomesticMatchNormalZRateByIDResponse ** p = (_ns1__GetDomesticMatchNormalZRateByIDResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByIDResponse, sizeof(_ns1__GetDomesticMatchNormalZRateByIDResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDomesticMatchNormalZRateByIDResponse(struct soap *soap, _ns1__GetDomesticMatchNormalZRateByIDResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetDomesticMatchNormalZRateByIDResponse);
	if (soap_out_PointerTo_ns1__GetDomesticMatchNormalZRateByIDResponse(soap, tag?tag:"ns1:GetDomesticMatchNormalZRateByIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDomesticMatchNormalZRateByIDResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDomesticMatchNormalZRateByIDResponse(struct soap *soap, _ns1__GetDomesticMatchNormalZRateByIDResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDomesticMatchNormalZRateByIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, _ns1__GetDomesticMatchNormalZRateByID *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByID))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, const char *tag, int id, _ns1__GetDomesticMatchNormalZRateByID *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByID);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetDomesticMatchNormalZRateByID ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, const char *tag, _ns1__GetDomesticMatchNormalZRateByID **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDomesticMatchNormalZRateByID **)soap_malloc(soap, sizeof(_ns1__GetDomesticMatchNormalZRateByID *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDomesticMatchNormalZRateByID *)soap_instantiate__ns1__GetDomesticMatchNormalZRateByID(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetDomesticMatchNormalZRateByID ** p = (_ns1__GetDomesticMatchNormalZRateByID **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDomesticMatchNormalZRateByID, sizeof(_ns1__GetDomesticMatchNormalZRateByID), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, _ns1__GetDomesticMatchNormalZRateByID *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetDomesticMatchNormalZRateByID);
	if (soap_out_PointerTo_ns1__GetDomesticMatchNormalZRateByID(soap, tag?tag:"ns1:GetDomesticMatchNormalZRateByID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDomesticMatchNormalZRateByID ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDomesticMatchNormalZRateByID(struct soap *soap, _ns1__GetDomesticMatchNormalZRateByID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDomesticMatchNormalZRateByID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAVPolicyResponse(struct soap *soap, _ns1__GetAVPolicyResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAVPolicyResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAVPolicyResponse(struct soap *soap, const char *tag, int id, _ns1__GetAVPolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAVPolicyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAVPolicyResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAVPolicyResponse(struct soap *soap, const char *tag, _ns1__GetAVPolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAVPolicyResponse **)soap_malloc(soap, sizeof(_ns1__GetAVPolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAVPolicyResponse *)soap_instantiate__ns1__GetAVPolicyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAVPolicyResponse ** p = (_ns1__GetAVPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAVPolicyResponse, sizeof(_ns1__GetAVPolicyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAVPolicyResponse(struct soap *soap, _ns1__GetAVPolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAVPolicyResponse);
	if (soap_out_PointerTo_ns1__GetAVPolicyResponse(soap, tag?tag:"ns1:GetAVPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAVPolicyResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAVPolicyResponse(struct soap *soap, _ns1__GetAVPolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAVPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAVPolicy(struct soap *soap, _ns1__GetAVPolicy *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAVPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAVPolicy(struct soap *soap, const char *tag, int id, _ns1__GetAVPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAVPolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAVPolicy ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAVPolicy(struct soap *soap, const char *tag, _ns1__GetAVPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAVPolicy **)soap_malloc(soap, sizeof(_ns1__GetAVPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAVPolicy *)soap_instantiate__ns1__GetAVPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAVPolicy ** p = (_ns1__GetAVPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAVPolicy, sizeof(_ns1__GetAVPolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAVPolicy(struct soap *soap, _ns1__GetAVPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAVPolicy);
	if (soap_out_PointerTo_ns1__GetAVPolicy(soap, tag?tag:"ns1:GetAVPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAVPolicy ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAVPolicy(struct soap *soap, _ns1__GetAVPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAVPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__MatchCommonPolicyResponse(struct soap *soap, _ns1__MatchCommonPolicyResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__MatchCommonPolicyResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__MatchCommonPolicyResponse(struct soap *soap, const char *tag, int id, _ns1__MatchCommonPolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__MatchCommonPolicyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__MatchCommonPolicyResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__MatchCommonPolicyResponse(struct soap *soap, const char *tag, _ns1__MatchCommonPolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__MatchCommonPolicyResponse **)soap_malloc(soap, sizeof(_ns1__MatchCommonPolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__MatchCommonPolicyResponse *)soap_instantiate__ns1__MatchCommonPolicyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__MatchCommonPolicyResponse ** p = (_ns1__MatchCommonPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__MatchCommonPolicyResponse, sizeof(_ns1__MatchCommonPolicyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__MatchCommonPolicyResponse(struct soap *soap, _ns1__MatchCommonPolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__MatchCommonPolicyResponse);
	if (soap_out_PointerTo_ns1__MatchCommonPolicyResponse(soap, tag?tag:"ns1:MatchCommonPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__MatchCommonPolicyResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__MatchCommonPolicyResponse(struct soap *soap, _ns1__MatchCommonPolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__MatchCommonPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__MatchCommonPolicy(struct soap *soap, _ns1__MatchCommonPolicy *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__MatchCommonPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__MatchCommonPolicy(struct soap *soap, const char *tag, int id, _ns1__MatchCommonPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__MatchCommonPolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__MatchCommonPolicy ** SOAP_FMAC4 soap_in_PointerTo_ns1__MatchCommonPolicy(struct soap *soap, const char *tag, _ns1__MatchCommonPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__MatchCommonPolicy **)soap_malloc(soap, sizeof(_ns1__MatchCommonPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__MatchCommonPolicy *)soap_instantiate__ns1__MatchCommonPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__MatchCommonPolicy ** p = (_ns1__MatchCommonPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__MatchCommonPolicy, sizeof(_ns1__MatchCommonPolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__MatchCommonPolicy(struct soap *soap, _ns1__MatchCommonPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__MatchCommonPolicy);
	if (soap_out_PointerTo_ns1__MatchCommonPolicy(soap, tag?tag:"ns1:MatchCommonPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__MatchCommonPolicy ** SOAP_FMAC4 soap_get_PointerTo_ns1__MatchCommonPolicy(struct soap *soap, _ns1__MatchCommonPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__MatchCommonPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAlterCommonPolicyResponse(struct soap *soap, _ns1__GetAlterCommonPolicyResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAlterCommonPolicyResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAlterCommonPolicyResponse(struct soap *soap, const char *tag, int id, _ns1__GetAlterCommonPolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAlterCommonPolicyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAlterCommonPolicyResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAlterCommonPolicyResponse(struct soap *soap, const char *tag, _ns1__GetAlterCommonPolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAlterCommonPolicyResponse **)soap_malloc(soap, sizeof(_ns1__GetAlterCommonPolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAlterCommonPolicyResponse *)soap_instantiate__ns1__GetAlterCommonPolicyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAlterCommonPolicyResponse ** p = (_ns1__GetAlterCommonPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAlterCommonPolicyResponse, sizeof(_ns1__GetAlterCommonPolicyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAlterCommonPolicyResponse(struct soap *soap, _ns1__GetAlterCommonPolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAlterCommonPolicyResponse);
	if (soap_out_PointerTo_ns1__GetAlterCommonPolicyResponse(soap, tag?tag:"ns1:GetAlterCommonPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAlterCommonPolicyResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAlterCommonPolicyResponse(struct soap *soap, _ns1__GetAlterCommonPolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAlterCommonPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAlterCommonPolicy(struct soap *soap, _ns1__GetAlterCommonPolicy *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAlterCommonPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAlterCommonPolicy(struct soap *soap, const char *tag, int id, _ns1__GetAlterCommonPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAlterCommonPolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAlterCommonPolicy ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAlterCommonPolicy(struct soap *soap, const char *tag, _ns1__GetAlterCommonPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAlterCommonPolicy **)soap_malloc(soap, sizeof(_ns1__GetAlterCommonPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAlterCommonPolicy *)soap_instantiate__ns1__GetAlterCommonPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAlterCommonPolicy ** p = (_ns1__GetAlterCommonPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAlterCommonPolicy, sizeof(_ns1__GetAlterCommonPolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAlterCommonPolicy(struct soap *soap, _ns1__GetAlterCommonPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAlterCommonPolicy);
	if (soap_out_PointerTo_ns1__GetAlterCommonPolicy(soap, tag?tag:"ns1:GetAlterCommonPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAlterCommonPolicy ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAlterCommonPolicy(struct soap *soap, _ns1__GetAlterCommonPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAlterCommonPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAllCommonPolicyZIPResponse(struct soap *soap, _ns1__GetAllCommonPolicyZIPResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAllCommonPolicyZIPResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAllCommonPolicyZIPResponse(struct soap *soap, const char *tag, int id, _ns1__GetAllCommonPolicyZIPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAllCommonPolicyZIPResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAllCommonPolicyZIPResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAllCommonPolicyZIPResponse(struct soap *soap, const char *tag, _ns1__GetAllCommonPolicyZIPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAllCommonPolicyZIPResponse **)soap_malloc(soap, sizeof(_ns1__GetAllCommonPolicyZIPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAllCommonPolicyZIPResponse *)soap_instantiate__ns1__GetAllCommonPolicyZIPResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAllCommonPolicyZIPResponse ** p = (_ns1__GetAllCommonPolicyZIPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAllCommonPolicyZIPResponse, sizeof(_ns1__GetAllCommonPolicyZIPResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAllCommonPolicyZIPResponse(struct soap *soap, _ns1__GetAllCommonPolicyZIPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAllCommonPolicyZIPResponse);
	if (soap_out_PointerTo_ns1__GetAllCommonPolicyZIPResponse(soap, tag?tag:"ns1:GetAllCommonPolicyZIPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAllCommonPolicyZIPResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAllCommonPolicyZIPResponse(struct soap *soap, _ns1__GetAllCommonPolicyZIPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAllCommonPolicyZIPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAllCommonPolicyZIP(struct soap *soap, _ns1__GetAllCommonPolicyZIP *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAllCommonPolicyZIP))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAllCommonPolicyZIP(struct soap *soap, const char *tag, int id, _ns1__GetAllCommonPolicyZIP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAllCommonPolicyZIP);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAllCommonPolicyZIP ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAllCommonPolicyZIP(struct soap *soap, const char *tag, _ns1__GetAllCommonPolicyZIP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAllCommonPolicyZIP **)soap_malloc(soap, sizeof(_ns1__GetAllCommonPolicyZIP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAllCommonPolicyZIP *)soap_instantiate__ns1__GetAllCommonPolicyZIP(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAllCommonPolicyZIP ** p = (_ns1__GetAllCommonPolicyZIP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAllCommonPolicyZIP, sizeof(_ns1__GetAllCommonPolicyZIP), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAllCommonPolicyZIP(struct soap *soap, _ns1__GetAllCommonPolicyZIP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAllCommonPolicyZIP);
	if (soap_out_PointerTo_ns1__GetAllCommonPolicyZIP(soap, tag?tag:"ns1:GetAllCommonPolicyZIP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAllCommonPolicyZIP ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAllCommonPolicyZIP(struct soap *soap, _ns1__GetAllCommonPolicyZIP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAllCommonPolicyZIP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAllCommonPolicyResponse(struct soap *soap, _ns1__GetAllCommonPolicyResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAllCommonPolicyResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAllCommonPolicyResponse(struct soap *soap, const char *tag, int id, _ns1__GetAllCommonPolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAllCommonPolicyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAllCommonPolicyResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAllCommonPolicyResponse(struct soap *soap, const char *tag, _ns1__GetAllCommonPolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAllCommonPolicyResponse **)soap_malloc(soap, sizeof(_ns1__GetAllCommonPolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAllCommonPolicyResponse *)soap_instantiate__ns1__GetAllCommonPolicyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAllCommonPolicyResponse ** p = (_ns1__GetAllCommonPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAllCommonPolicyResponse, sizeof(_ns1__GetAllCommonPolicyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAllCommonPolicyResponse(struct soap *soap, _ns1__GetAllCommonPolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAllCommonPolicyResponse);
	if (soap_out_PointerTo_ns1__GetAllCommonPolicyResponse(soap, tag?tag:"ns1:GetAllCommonPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAllCommonPolicyResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAllCommonPolicyResponse(struct soap *soap, _ns1__GetAllCommonPolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAllCommonPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAllCommonPolicy(struct soap *soap, _ns1__GetAllCommonPolicy *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAllCommonPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAllCommonPolicy(struct soap *soap, const char *tag, int id, _ns1__GetAllCommonPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAllCommonPolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAllCommonPolicy ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAllCommonPolicy(struct soap *soap, const char *tag, _ns1__GetAllCommonPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAllCommonPolicy **)soap_malloc(soap, sizeof(_ns1__GetAllCommonPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAllCommonPolicy *)soap_instantiate__ns1__GetAllCommonPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAllCommonPolicy ** p = (_ns1__GetAllCommonPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAllCommonPolicy, sizeof(_ns1__GetAllCommonPolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAllCommonPolicy(struct soap *soap, _ns1__GetAllCommonPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAllCommonPolicy);
	if (soap_out_PointerTo_ns1__GetAllCommonPolicy(soap, tag?tag:"ns1:GetAllCommonPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAllCommonPolicy ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAllCommonPolicy(struct soap *soap, _ns1__GetAllCommonPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAllCommonPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
